
\chapter{JConHT -- A \texorpdfstring{\SHOIQSHOIQ}{SHOIQ[SHOIQ]} Reasoner}
\label{cha:jconht}

In the last chapter we presented a mapping for role-based models into contextualized description
logic ontologies. This step can be done automatically and it therefore helps the automated
processing and investigation of role-based models. But one final step in this workflow is still
missing. A reasoner that is capable of handling these ontologies is necessary in order to check the
consistency automatically.

Since the translation for role-based models only produces \LMLO-ontologies, i.e.\ conjunctions of
meta axioms, we will also only consider \LMLO-ontologies. Throughout this chapter, let $\Omf=(\Omc,\RM,\RO)$ denote a
\SHOIQSHOIQ-ontology and let \bsf denote the bijection as in
Definition~\ref{def:outer-abstraction}. Hence, \Ob denotes the outer abstraction of \Omc. We also
remind the reader that the \emph{restricted type} is the $\ran(\bsf)$-type (see
Definition~\ref{def:int-respects-D}) of some element and thus a subset of $\ran(b)$.

In this chapter we will present a practical algorithm to check consistency.  Furthermore, we
implemented this algorithm and give details on the design of the implementation.  Since internally
it only calls standard DL consistency checks, we can reuse existing, highly optimized DL reasoners.


\section{A Black-Box Approach}
\label{sec:blackbox-approach}

In Section~\ref{sec:complexity-consis-problem}, we showed that we can reduce the consistency problem
of \LMLO to two separate decision problems. Now, the general idea for an implementation is to use
existing, highly optimized and performant reasoners as black-boxes for these subtasks. 
%
In this section we will discuss how the two subtasks, namely admissibility of a set~\Xmc and outer
consistency w.r.t.~\Xmc, can be reduced to standard reasoning tasks.


\subsection{Admissibility}
\label{sec:admissibility}

In the definition of admissibility (Definition~\ref{def:admissibility}), where we define $\Bmc_{X_{i}}$,
we require negated o-axioms. Negated axioms, especially negated GCIs, are usually not supported by
classical description logic reasoners. Therefore, we introduce the notion of \emph{weakly negated
  axioms}.

\begin{definition}[Weakly negated axioms]
  Let $\alpha$ be an axiom over \Nsig, then the \emph{weakly negated axiom $\alpha^{*}$} is defined
  as follows:
  \begin{itemize}
  \item if $\alpha = C \sqsubseteq D$, then $\alpha^{*} \coloneqq (C \sqcup \lnot D)(x)$ where $x$
    is a fresh variable,
  \item if $\alpha = C(a)$, then $\alpha^{*} \coloneqq (\lnot C)(a)$, and
%  \item if $\alpha = r(a,b)$, then $\alpha^{*} \coloneqq \lnot r(a,b)$, and
  \item for all other $\alpha$, $\alpha^{*} \coloneqq \lnot \alpha$. \qedhere
  \end{itemize}
\end{definition}

Note here, that for concept assertions the negation of the axiom $\lnot\alpha$ and weakly negated
axiom $\alpha^{*}$ are semantically equal, but not syntactical since $\lnot\alpha$ uses axiom
negation, while $\alpha^{*}$ only requires concept negation. Furthermore, in the presence of
nominals we could rewrite a negated role assertion of the form $\lnot r(a,b)$ as
$(\lnot\exists r.\{b\})(a)$. But as OWL reasoners in general support negated role assertions, we
keep $\lnot r(a,b)$.  Moreover, this definition reflects the aspect of
%
\todo{soundness and completeness?  Are these the correct terms here???}
%
soundness, i.e.\ $\alpha\land\alpha^{*}$ is inconsistent, but not completeness,
i.e.~$\I\models\alpha\lor\alpha^{*}$ does not hold for all interpretations \I.

\begin{lemma}\label{lem:weakly-negation-inconsistent}
  Let $\alpha$ be an axiom. Then,
  \begin{enumerate}
  \item $\alpha\land\alpha^{*}$ is inconsistent, and
  \item if $\I\not\models\alpha$, then there exists an interpretation $\I'$ such that $\I'\models\alpha^{*}$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Let $\alpha = C \sqsubseteq D$ and $\alpha^{*} = (C \sqcup \lnot D)(x_{\mathsf{new}})$. Assume
  that $\I \models \alpha$ and $\I \models C(x_{\mathsf{new}})$.  Then, we know that
  ${x_{\mathsf{new}}}^{\I} \in C^{\I} \subseteq D^{\I}$. Thus we have
  ${x_{\mathsf{new}}}^{\I} \in D^{\I}$ and clearly
  ${x_{\mathsf{new}}}^{\I} \notin (C \sqcap \lnot D)^{\I}$. Hence,
  $C \sqsubseteq D \land (C \sqcap \lnot D)(x_{\mathsf{new}})$ is inconsistent.

  If $\I\not\models C \sqsubseteq D$, then there exists $d\in\Delta^{\I}$ such that
  $d \in C^{\I} \cap (\lnot D)^{\I}$. Then, the interpretation~$\I'$, obtained from \I by setting
  ${x_{\mathsf{new}}}^{\I'} \coloneqq d$, models $\alpha^{*}$.

  For the other axioms, the weakly negated axiom is defined as the normally negated axiom and the
  claim follows directly from the definition of $\models$ (see Definition
  \ref{def:semantics-of-axioms}).
\end{proof}

To check admissibility of a set of types, we distinguish whether or not rigid names are present. In
the latter case, i.e.\ $\OCR=\ORR=\emptyset$, the first condition of
Definition~\ref{def:admissibility} is always fulfilled. W.l.o.g., we can interpret the individual
names the same in every interpretation. Therefore, we can check each $\Bmf_{X_{i}}$ separately. We
show that it is sufficient to consider the weakly negated axioms.

% \begin{definition}[Sets of positive and negative induced o-axioms]
%   Let $\Xmc = \{X_{1}, \ldots, X_{k}\}$ be a set of restricted types. Then, the \emph{sets of
%     positive induced o-axioms $\Xposi$} are defined as
%   \begin{align*}
%     \Xposi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in X_{i}\}.\\
%   \intertext{The \emph{sets of negative induced o-axioms \Xnegi} are defined as}
%     \Xnegi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\}.\qedhere
%   \end{align*}
% \end{definition}


\begin{lemma}\label{lem:admissibility-without-rigid}
  If no rigid names are present, i.e.\ $\OCR=\ORR=\emptyset$, the set $\Xmc = \{X_{1}, \ldots, X_{k}\}$ of restricted types is
  admissible iff $\Omf_{X_{i}} = (\Omc_{X_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$, where
  $\Omc_{X_{i}}$ is defined as
  \begin{align*}
    \Omc_{X_{i}}:=\bigwedge_{\bsf(\oax{\alpha})\in X_{i}}\alpha\ \land \bigwedge_{\bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}}\alpha^{*}.
  \end{align*}
\end{lemma}
\begin{proof}
  Assume that \Xmc is admissible. Then there exists \Osig-interpretations
  $\I_1=(\Delta,\cdot^{\I_1})$,~\dots, $\I_k=(\Delta,\cdot^{\I_k})$ such that every $\I_i$,
  $1\le i\le k$, is a model of $\Bmf_{X_{i}}$ where $\Bmf_{X_{i}}$ is defined as in
  Definition~\ref{def:admissibility}. 
  Let \Xposi and \Xnegi, respectively, denote the sets of positive and negative induced o-axioms
  \begin{align*}
    \Xposi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in X_{i}\}\text{, and}\\
    \Xnegi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\}.
  \end{align*}
  %
  By definition of \Xposi and \Xnegi, $\I_{i}$ is a model of
  $\smash{\bigwedge_{\alpha\in\Xposi}\alpha}$ and $\smash{\bigwedge_{\alpha\in\Xnegi}\lnot\alpha}$.
  %
  Then, let $\Xnegi=\{\alpha_{i,1}, \ldots, \alpha_{i,\ell_{i}}\}$. We have that
  $\I_{i}\models \lnot\alpha_{i,j}$ for $1 \leq j \leq \ell_{i}$. By Lemma
  \ref{lem:weakly-negation-inconsistent}, we get that there exists ${\I_{i}}'$ such that
  ${\I_{i}}'\models {\alpha_{i,j}}^{*}$. By induction, we get that ${\I_{i}}'\models\Omf_{X_{i}}$.

  If all $\Omf_{X_{i}}$ are consistent, there exist interpretations $\I_{i}$ such that
  $\I_{i}\models\Omf_{X_{i}}$. W.l.o.g., we can assume that $\I_{i}$ share the same domain $\Delta$
  and that individual names are interpreted the same.  Then, $\I_{i}$ is a model of
  $\bigwedge_{\bsf(\oalpha)\in X_i}\alpha$,
  $\bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\alpha^{*}$ and \RO. Due to Lemma
  \ref{lem:weakly-negation-inconsistent}, $\I_{i}$ also models
  $\bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha$. Hence, $\Xmc$ is admissible.
\end{proof}

In the former case, i.e.\ $\OCR\cup\ORR\neq\emptyset$, we use the renaming technique
of~\cite{BaGL-KR08,BaGL-ToCL12} as in the proof of
Theorem~\ref{thm:shoiqshoq-with-rigid-names-twoexptime}. Due to the interaction of the rigid names,
we must reason over all $\Bmf_{X_{i}}$ simultaneously.

\begin{definition}[Renamed axiom, Sets of positive and negative induced renamed o-axioms, Induced
  object ontology]\label{def:renaming}
  Let $\Xmc = \{X_{1}, \ldots, X_{k}\}$ be a set of restricted types and let $\alpha$ be an axiom
  over \Osig.
  %
  For $\iota\in\nat$, the \emph{renamed axiom $\alpha^{(\iota)}$} is obtained from $\alpha$
  by replacing all flexible concept names $A$, i.e.\ $A \in \OC \setminus \OCR$, with a copy $A^{(\iota)}$
  and all flexible role names $r$ with a copy $r^{(\iota)}$ where we assume w.l.o.g.\ that $A^{(\iota)}$ and
  $r^{(\iota)}$ do not occur in \Bmf.
  
  Then, the \emph{set of positive induced renamed o-axioms \Xpos}, the \emph{set of negative induced
    renamed o-axioms \Xneg}, the \emph{renamed object RBox $\RO'$} and the \emph{induced object
    ontology $\Omf_{\Xmc}=(\Omc_{\Xmc},\RO')$} are defined as follows:
  \begin{align*}
    \Xpos & \coloneqq \smash{\bigcup_{i=1}^{k}}\vphantom{\bigcup_{i}}\{\alpha^{(i)} \mid \bsf(\oax{\alpha})\in X_{i}\},\\
    \Xneg & \coloneqq \bigcup_{i=1}^{k}\{\alpha^{(i)} \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\},\\
    \RO' & \coloneqq \bigcup_{i=1}^{k}\{\alpha^{(i)} \mid \alpha\in\RO\} \text{, and}\\
    \Omc_{\Xmc} & \coloneqq \bigwedge_{\beta\in\Xpos} \beta\ \land\ \bigwedge_{\beta\in\Xneg}
                  \beta^{*}.
  \end{align*}

  \vspace{-1.7\baselineskip}
\end{definition}

Although the next lemma also holds if no rigid names are present, we state it explicitly with rigid
names, as in the other case we will use Lemma~\ref{lem:admissibility-without-rigid}. From now on,
let $\alpha$ always denote an original axiom and $\beta$ an renamed axiom.

\begin{lemma}\label{lem:admissibiliy-with-rigid}
  If rigid names are present, i.e.\ $\OCR\cup\ORR\neq\emptyset$, the set \Xmc of restricted types is
  admissible iff the induced object ontology $\Omf_{\Xmc}$ is consistent.
\end{lemma}
\begin{proof}
  We can reuse the claim made in the proof of
  Theorem~\ref{thm:shoiqshoq-with-rigid-names-twoexptime}: \Xmc is admissible iff $\Bmf_{\Xmc}$ is
  consistent where $\Bmf_{\Xmc}$ is defined as
  \begin{align*}
    \Bmf_\Xmc \coloneqq \left(\bigwedge\nolimits_{1\leq\iota\leq k}\left(\bigwedge_{\bsf(\oalpha)\in X_{\iota}}\alpha^{(\iota)}\ \land
      \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_{\iota}}\lnot\alpha^{(\iota)}\right), \quad\RO'\right).
  \end{align*}
  %
  Hence, we only have to show that $\Bmf_{\Xmc}$ is consistent iff $\Omf_{\Xmc}$ is consistent. Let
  $\Xneg=\{\beta_{1}, \ldots, \beta_{\ell}\}$.

  If there exists an \Osig-interpretation \Gmc such that $\Gmc\models\Bmf_{\Xmc}$, then we also have
  that $\Gmc\models\lnot\beta_{i}$ for all $1 \leq i \leq \ell$. Due to
  Lemma~\ref{lem:weakly-negation-inconsistent} and by induction, there is some $\Gmc'$ such that
  $\Gmc'\models\beta_{i}^{*}$ for all $1 \leq i \leq \ell$. Hence, $\Gmc'$ is a model of $\Omf_{\Xmc}$.

  Conversely, if there exists an \Osig-interpretation \Gmc such that $\Gmc\models\Omf_{\Xmc}$, then we also have
  that $\Gmc\models\beta_{i}^{*}$ for all $1 \leq i \leq \ell$. By
  Lemma~\ref{lem:weakly-negation-inconsistent}, we know that $\Gmc\not\models\beta_{i}$. Hence,
  $\Gmc\models\lnot\beta_{i}$ and $\Gmc\models\Bmf_{\Xmc}$.
  


  % If $\Omc_{\Xmc}$ is consistent, then there exists an interpretation \II such that
  % $\I\models\Omc_{\Xmc}$. Let $\Xneg=\{\beta_{1}, \ldots, \beta_{l}\}$. We have that
  % $\I\models{\beta_{j}}^{*}$ for $1 \leq j \leq l$. By Lemma \ref{lem:weakly-negation-inconsistent}
  % we know that $\I\not\models\beta_{j}$ and, hence, $\I\models\lnot\beta_{j}$. By induction, we get
  % \begin{align*}
  %   \I \models & \left(\bigwedge_{\beta\in\Xpos} \beta\ \land\ \bigwedge_{\beta\in\Xneg} \lnot\beta,
  %   \quad\RO'  \right)
  % \end{align*}
  % We define \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1}), \ldots, \I_k=(\Delta,\cdot^{\I_k})$
  % as follows:
  % \begin{align*}
  %   \Delta & \coloneqq \Delta^{\I},\\
  %   A^{\I_{i}} & \coloneqq A^{\I} \qquad \text{for all $A\in\OCR$ occurring in \Xmc,}\\
  %   A^{\I_{i}} & \coloneqq (A^{(i)})^{\I} \qquad \text{for all $A\in\OC\setminus\OCR$ occurring in \Xmc,}\\
  %   r^{\I_{i}} & \coloneqq r^{\I} \qquad \text{for all $r\in\ORR$ occurring in \Xmc,}\\
  %   r^{\I_{i}} & \coloneqq (r^{(i)})^{\I} \qquad \text{for all $r\in\OR\setminus\ORR$ occurring in
  %                \Xmc, and}\\
  %   a^{\I_{i}} & \coloneqq a^{\I} \qquad \text{for all $a\in\OI$ occurring in \Xmc.}
  % \end{align*}
  % Condition (I) of Definition \ref{def:admissibility} is fulfilled since rigid names and individual
  % names are defined the same for all $\I_{i}$.
  % %
  % By the definition of $\I_{i}$, we have that $\I_{i}\models\alpha$ iff
  % $\I\models\alpha^{(i)}$. Hence, we know that $\I_{i}$ is a model of
  % $\bigwedge_{\bsf(\oax{\alpha})\in X_{i}}\alpha$,
  % $\bigwedge_{\bsf\oax{\alpha}\in\ran(\bsf)\setminus X_{i}}\lnot\alpha$ and \RO and \Xmc is
  % admissible.

  % If \Xmc is admissible, then there exist \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1})$,
  % \ldots, $\I_k=(\Delta,\cdot^{\I_k})$ such that $x^{\I_i}=x^{\I_j}$ for all
  % $x\in\OI\cup\OCR\cup\ORR$ and all $i,j\in\{1,\dots,k\}$, and every $\I_i$, $1\le i\le k$, is a
  % model of the \LO-BKB $\Bmf_{X_{i}}= (\B_{X_i},\RO)$ over~\Osig where
  % $\B_{X_i}:=\bigwedge_{\bsf(\oalpha)\in X_i}\alpha\ \land
  % \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha$. We define the
  % \Osig-interpretation \II as follows:
  % \begin{align*}
  %   \Delta^{\I} & \coloneqq \Delta,\\
  %   A^{\I} & \coloneqq A^{\I_{i}} \qquad \text{for $A\in\OCR$ and some $1\leq i \leq k$,}\\
  %   (A^{(i)})^{\I} & \coloneqq A^{\I_{i}} \qquad \text{for $A\in\OC\setminus\OCR$,}\\
  %   r^{\I} & \coloneqq r^{\I_{i}} \qquad \text{for $r\in\ORR$ and some $1\leq i \leq k$,}\\
  %   (r^{(i)})^{\I} & \coloneqq r^{\I_{i}} \qquad \text{for $r\in\OR\setminus\ORR$, and}\\
  %   a^{\I} & \coloneqq a^{\I_{i}} \qquad \text{for $a\in\OI$ and some $1\leq i \leq k$.}\\
  % \end{align*}
  % Again, by definition of \I, we have that $\I\models\alpha^{(i)}$ iff $\I_{i}\models\alpha$. Thus, we
  % get that \I is a model of $\bigwedge_{\beta\in\Xpos} \beta$,
  % $\bigwedge_{\beta\in\Xneg} \lnot\beta$ and $\RO'$. Due to Lemma
  % \ref{lem:weakly-negation-inconsistent}, \I is also models $\bigwedge_{\beta\in\Xneg}
  % \beta^{*}$. Hence, $\Omc_{\Xmc}$ is consistent.
\end{proof}

To sum up, we can decide admissibility of~\Xmc by checking, respectively,~$\Omf_{\Xmc}$
or~$\Omf_{X_{i}}$ for consistency, depending on whether rigid names are present or not. 


\subsection{Outer consistency}
\label{sec:outer-consistency-to-standard-reasoning}

In the decision procedures described in Section~\ref{sec:complexity-consis-problem} we always construct the set \Xmc first,
and then check whether \Bmfb is outer consistent w.r.t.~\Xmc. In the general case with rigid names
we enumerate all sets $\Xmc\subseteq\powerset{\ran(\bsf)}$. When only rigid concept names and no
rigid role names are present we non-deterministically guess a set \Xmc and for the case without
rigid names we construct the largest possible set \Xmc that is admissible and argue that any \Bmfb
that is outer consistent w.r.t.\ some admissible $\Xmc'$ is also outer consistent w.r.t.~\Xmc. Hence,
we only have to test outer consistency w.r.t.\ to \Xmc. But all these techniques involve the possibly
unnecessary, exponentially large construction of \Xmc.
%
Alternatively, we can also use the following lemma which is a direct consequence of
Lemma~\ref{lem:admissible-and-outerConsistent}.

\begin{lemma}
  \label{lem:consistant-and-admissible-types}
  The \LMLO-BKB \Bmf is consistent iff there is an \Msig-interpretation \Hmc such that
  $\Hmc \models \Bmfb$ and $\Zmc_{\Hmc} = \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}$
  is admissible.
\end{lemma}

\begin{proof}
  Let us assume that \Bmf is consistent.
  By Lemma~\ref{lem:admissible-and-outerConsistent} we know, if \Bmf is consistent than there exists
  an admissible set \Xmc such that \Bmfb is outer consistent w.r.t~\Xmc. By the definition of outer
  consistency there exists an \Msig-interpretation \Hmc that models \Bmfb and weakly respects
  $(\ran(\bsf), \Xmc)$.  By definition we have that $\Zmc_{\Hmc} \subseteq \Xmc$. Since every subset of an
  admissible set is also admissible, \Zmc is also admissible.

  For the `if' direction we assume that $\Hmc \models \Bmfb$ and that \Zmc is admissible.
  If $\Hmc \models \Bmfb$, then \Bmfb is outer consistent w.r.t~\Zmc. Since \Zmc is admissible, we
  know, due to Lemma~\ref{lem:admissible-and-outerConsistent}, that \Bmf is consistent.
\end{proof}



Due to Lemma \ref{lem:consistant-and-admissible-types}, we do not need to construct the set \Xmc
first. We can also enumerate all models \Hmc of \Bmfb, and check for each \Hmc if the occurring
types are admissible. Of course, if there exist one model of \Bmfb, then there exists infinitely
many. But we only need to check those that are \emph{essentially different}, i.e.\ the set of
occurring restricted types differs.

\begin{definition}[Essentially equal interpretations]
  For an \Msig-interpretation \Hmc, the \emph{set of occurring, restricted types $\Zmc_{\Hmc}$} is defined as
  \begin{align*}
    \Zmc_{\Hmc} & \coloneqq \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}.
  \end{align*}
  The two \Msig-interpretations $\Hmc_{1}$ and $\Hmc_{2}$ are \emph{essentially equal} if $\Zmc_{\Hmc_{1}} =
  \Zmc_{\Hmc_{2}}$.
\end{definition}

Using the results of Lemma \ref{lem:admissibility-without-rigid}, \ref{lem:admissibiliy-with-rigid}
and \ref{lem:consistant-and-admissible-types}, we can construct a simple algorithm, as depicted in
Algorithm~\ref{alg:1}. Here, $\Omc_{Z_{i}}$ and $\Omc_{\Zmc_{\Hmc}}$ are, respectively, defined as in
Lemma~\ref{lem:admissibility-without-rigid} and Definition~\ref{def:renaming}. We enumerate all
essentially equal models of \Bmfb and check for each model \Hmc whether $\Zmc_{\Hmc}$ is
admissible. Note that on the object level only classical consistency checks are used. On meta level,
the bare information about consistency is not sufficient, since we also need the knowledge about the
restricted types occurring in the model. Hence, we need a DL reasoner that constructs a model and,
if consistent, returns the set of occurring restricted types.


\IncMargin{1em}
\RestyleAlgo{ruled}
\begin{algorithm}[t]
  \SetAlgoVlined
  \setstretch{1.1}
  \DontPrintSemicolon
  \SetKwData{true}{true}
  \SetKwData{false}{false}
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  %
  \Input{\LMLO-BKB \Bmf}
  \Output{\true if \Bmf is consistent, \false otherwise}
  \BlankLine
  $\Hmf \coloneqq \{\Hmc \mid \Hmc\models\Bmfb \text{, up to essential equality}\}$\;
  \For{$\Hmc \in \Hmf$}{
    $\Zmc_{\Hmc} \coloneqq \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}$\;
    \eIf{\Bmf contains rigid names}{
      \If{($\Omc_{\Zmc_{\Hmc}}, \RO')$ is consistent}{
        \vspace{0.5ex}\Return{\true}
      }
    }{
      $\Zmc_{\Hmc} = \{Z_{1}, \dots, Z_{k}\}$\;
      \If{$(\Omc_{Z_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$}{
        \vspace{0.5ex}\Return{\true}
      }
    }
  }
  \Return{false}
  \caption{Algorithm for checking consistency of \LMLO-BKB \Bmf}\label{alg:1}
\end{algorithm}

\begin{lemma}\label{lem:alg1-sound-complete-terminating}
  Algorithm~\ref{alg:1} is sound, complete, and terminating.
\end{lemma}
\begin{proof}
  The set of essential equal models is finite. Checking whether \Hmc is a model and checking whether
  $\Omf_{\Zmc_{\Hmc}}$ or $\Omf_{Z_{i}}$ is consistent, is decidable. Thus, Algorithm~\ref{alg:1}
  terminates.

  Let us assume that \Bmf is consistent. By Lemma~\ref{lem:consistant-and-admissible-types}, there
  exists a model~\Hmc of~\Bmfb such that~$\Zmc_{\Hmc}$ is admissible. W.l.o.g., we can assume that
  $\Hmc\in\Hmf$. 
  %
  % Then, there exists a model \J of \Bmf and, hence, there is a model $\Hmc\in\Hmf$ of \Bmfb such
  % that \Hmc and \Jb are essential equal. By Lemma~\ref{lem:consistant-and-admissible-types},
  % $\Zmc_{\Hmc}$ is admissible.
  % 
  Depending on whether rigid names are present, Algorithm~\ref{alg:1} will successfully check that
  $\Omf_{Z_{i}}$, for all $1\leq i \leq k$, or $\Omf_{\Zmc_{\Hmc}}$ is consistent, due to
  Lemma~\ref{lem:admissibility-without-rigid} and Lemma~\ref{lem:admissibiliy-with-rigid}. Hence, it
  returns \true.

  Let us assume that the algorithm returns \true. Then, there is some $\Hmc\in\Hmf$ such that~$\Omf_{Z_{i}}$,
  for all $1\leq i \leq k$, or~$\Omf_{\Zmc_{\Hmc}}$ is consistent. By
  Lemma~\ref{lem:admissibility-without-rigid} or Lemma~\ref{lem:admissibiliy-with-rigid}, we know
  that $\Zmc_{\Hmc}$ is admissible. Lemma~\ref{lem:consistant-and-admissible-types} yields that \Bmf
  is consistent.
\end{proof}



\section{Contextual Hypertableau}
\label{sec:using-hypertableau}

We have to take several arguments into account in order to evaluate, which reasoner or decision
procedure we use as core reasoner to decide the two subtasks.
%
First of all as mentioned earlier, in addition to checking consistency on meta level, we also need
the set of occurring restricted types of a model. Hence, an reasoner that constructs a model is
necessary for enumerating the models of \Bmfb. As pointed out in~\cite{MaLHSP-ORE15}, there exist
three major calculi used in OWL reasoners: consequence-, model construction- and
rewriting-based. \emph{Consequence-based} calculi are most often employed for the entailment problem in
lightweight DLs like \EL, while \emph{rewriting} techniques are usually used in specific reasoning tasks as
for query answering. \emph{Model construction-based} techniques are utilized for expressive DLs, i.e.\ any
extension of \ALC, and try to build a model based on the knowledge base to check consistency. These
include tableau and hypertableau techniques. Obviously, we are looking for a model
construction-based reasoner.

Furthermore, by means of maintenance, we will use the same reasoner for the meta level and the
object level.
%
Since a dominant framework supporting OWL, the OWL API~\cite{HoB-SW11} is implemented in Java, so is the
majority of the available reasoners. Hence, we also use Java for our OWL-conformant reasoner and
implement the \textsf{OWLReasoner} interface of the OWL API.

Last but not least, the performance of the reasoner in consistency checking is important for us. Therefore, 
we take a look at the OWL Reasoner Evaluation Competition Report~\cite{PaMGGS-SSWS15}, especially at
the results of the discipline: \emph{OWL DL Consistency}. This discipline, among others, was won by
Konclude~\cite{StLG-JWS14}, a C++-implemented hybrid reasoner that combines tableau calculus with a
variant of consequence-based saturation procedure. This hybrid approach, however, makes Konclude
unsuitable in our setting. The next candidate is HermiT~\cite{GHM-JAR14}, a Java-implemented
reasoner based on the hypertableau calculus~\cite{MoSH-JAIR09}. Since it meets all our
requirements, we use HermiT as core reasoner in our implementation.

% \todo[inline]{hypertableau avoid unnecessary nondeterminism (or-branching)}

% \todo[inline]{Hermit computes premodels which can be extended to model of ontology. blocked individuals, same
% concept labels -> premodel has the same restricted type}

% \todo[inline]{different blocking strategies dependant on used dl. anywhere blocking, ancestor blocking, atomic
% single blocking, full single blocking, }

% \todo[inline]{full subset blocking could be problematic, but is not used in HermiT.}

Before we discuss some details of our algorithm, we will present the relevant parts of the
Hypertableau Algorithm and refer the interested reader
to~\cite{MoSH-CADE07,MoSH-DL07,MoSH-JAIR09}. Like other tableau-based methods the hypertableau
calculus tries to construct an abstraction of a model for a given ontology to check whether that
ontology is consistent. But in contrast to the tableau calculus it operates on a set of
\emph{DL-clauses} and an ABox, instead of a TBox and an ABox. 

\begin{definition}[DL-Clause~\cite{MoSH-JAIR09}]
  \mbox{ }

  \todo[inline, color=blue!40]{what is a dl clause}
  \todo[inline, color=blue!40]{satisfiability of a dl clause}
\end{definition}

\todo[inline]{a few more hypertableau definitions\vspace*{2cm}}


Finally, we define the Hypertableau Algorithm.

\begin{definition}[Hypertableau Algorithm~\cite{MoSH-JAIR09}]

  Table~\ref{tab:derivation-rules} specifies \emph{derivation rules} that, given an ABox \A and a
  set of DL-Clauses \Cmc, derive one or more ABoxes $\A_{1},\dots,\A_{n}$.

  An ABox \A contains a \emph{clash} iff $\bot\in\A$. Otherwise, \A is \emph{clash-free}. 
  
  For a set of DL-clauses \Cmc and an input ABox \A, a \emph{derivation} is a pair $(T,\lambda)$
  where $T$ is a finitely branching tree and $\lambda$ is a function that labels the nodes of $T$
  with ABoxes such that for each node $t\in T$:
  \begin{itemize}
  \item $\lambda(t)=\A$ if $t$ is the root of $T$,
  \item $t$ is a leaf of $T$ if $\bot\in\lambda(t)$ or no derivation rule is applicable to
    $\lambda(t)$ and \Cmc, and
  \item $t$ has children $t_{1},\dots,t_{n}$ such that $\lambda(t_{1}),\dots,\lambda(t_{n})$ are
    exactly the results of applying one applicable rule to $\lambda(t)$ and \Cmc in all other
    cases.
  \end{itemize}
  An ABox is \emph{complete} iff it labels some leaf of $T$.
\end{definition}

\begin{table}
  \caption{Derivation rules of the hypertableau calculus~\cite{MoSH-JAIR09}}
  \label{tab:derivation-rules}
  \centering
  \begin{tabularx}{0.9\linewidth}{ll@{ }X}
    \toprule
    & If &  \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep,leftmargin=\widthof{3.}+\labelsep,topsep=0pt]
           \item $\mathbf{r} \in \Cmc$, where $\mathbf{r} = U_{1} \land\dots\land U_{m} \to V_{1}
             \lor\dots\lor V_{n}$, and
           \item a mapping $\sigma$ from the variables in $\mathbf{r}$ to the individuals of~\A
             exists such that 
             \begin{enumerate}[nosep,label*=\arabic*.,topsep=0pt]
             \item there is no $x\in\NV$ $\sigma(x)$ is indeirectly blocked,
             \item $\sigma(U_{i})\in\A$ for each $1\leq i \leq m$, and
             \item $\sigma(V_{j})\notin\A$ for each $1\leq j \leq n$
             \end{enumerate}%
           \end{enumerate} \\ 
    \multirow{-3}{*}[7ex]{\textit{Hyp}-rule} & then &
        $\A_{1} \coloneqq \A \cup \{\bot\}$ if $n=0$; \\
    & & $\A_{j} \coloneqq \A \cup \{\sigma(V_{j})\}$ for $1 \leq j \leq n$ otherwise.
      \\ \midrule
    & If & \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep]
           \item If
           \end{enumerate}
 \\
    \multirow{-2}{*}{$\geq$-rule} & then & test \\ \midrule
    & If & test\\
    \multirow{-2}{*}{$\approx$-rule} & then & 
       test \\ \midrule
    & If & test \\
    \multirow{-2}{*}{$\bot$-rule} & then &  test \\ \midrule
    & If & test \\
    \multirow{-2}{*}{\textit{NI}-rule} & then & test \\
    \bottomrule
  \end{tabularx}
\end{table}

As in tableau algorithms, to ensure termination the hypertableau calculus uses a blocking strategy.

In the hypertableau algorithm, other blocking strategies besides \textsf{Anywhere Blocking} can also
be applied dependant on the expressivity of the description logic, namely \textsf{Atomic Single
  Blocking} and \textsf{Full Single Blocking.}

\todo[inline]{finish paragraph about blocking}

% For brevity, we will present here only the relevant parts of the Hypertableau Algorithm and refer
% the interested reader to~\cite{MoSH-CADE07,MoSH-DL07,MoSH-JAIR09}. Like other tableau-based
% methods the hypertableau calculus tries to construct an abstraction of a model for a given ontology
% to check whether that ontology is consistent. But in contrast to the tableau calculi it operates
% on a set of \emph{DL-clauses} and an ABox, instead of a TBox and an ABox.




% \todo[inline, caption={paragraph about preprocessing}]{paragraph about preprocessing

%   \begin{itemize}
%   \item elimination of transitivity axioms
%   \item normalization
%   \item clausification
%   \end{itemize}
% }
% \begin{definition}[Clausification]
%   The \emph{clausification} of a \LM ontology $\Omc = (\T, \A)$ is the pair \CA \dots
% \end{definition}


% \begin{lemma}
%   A \SHOIQ ontology \Omc is consistent if and only if $\Xi(\Delta(\Omega(\Omc)))$ is consistent and
%   \todo[inline, color=blue!40]{set of restricted types are equal.\vspace{1cm}}
% \end{lemma}

% \todo[inline]{short introduction to hypertableau}

% \begin{definition}[Hypertableau Algorithm]
%   \mbox{ }

%   \todo[inline,color=blue!40]{ABoxes}
%   \todo[inline,color=blue!40]{Pairwise Anyway Blocking}
%   \todo[inline,color=blue!40]{Derivation Rules}
%   \todo[inline,color=blue!40]{Clash}
%   \todo[inline,color=blue!40]{Derivation, leaf node}
%   \todo[inline,color=blue!40]{complete ABox}
% \end{definition}

% In [BSH09] \todo{citation} it is shown that the hypertableau algorithm is sound, complete and
% terminating. 

% \todo[inline]{some paragraph explaining the next steps in our calculus}


Through the rest of this section let \CA be the clausification of $\Omf^{\bsf}$. Hence, \A is an \LM-ABox over
\Msig.
%
In Algorithm~\ref{alg:1}, we need to enumerate all models for \Bmfb up to essential equality. The
main idea is, that it is sufficient to look at the complete, clash-free ABoxes, since every model of
the ontology has such a corresponding ABox.

\begin{lemma}\label{lem:model-has-abox}
  In any derivation for \CA and for each model \Hmc of \CA, there exists some leaf node labelled with
  a clash-free ABox $\A'$ such that $\Hmc'\models\A'$ and \Hmc and $\Hmc'$ are essentially equal.
\end{lemma}
\begin{proof}
  We prove the lemma by induction on the derivation rule application. Let \Cmc be a set of
  DL-clauses, let \A be an ABox and let $\Hmc\models\CA$.
  
  Assume that the \textit{Hyp}-rule is applicable for
  $\mathbf{r} = U_{1} \land\dots\land U_{m} \to V_{1} \lor\dots\lor V_{n}\in\Cmc$. Then there is a
  mapping $\sigma$ from the variables in $\mathbf{r}$ to the individuals in \A such that
  $\sigma(U_{i})\in\A$ and $\sigma(V_{j})\notin\A$, for each $1\leq i \leq m$, $1\leq j \leq
  n$. Since $\Hmc\models\mathbf{r}$, there exists mapping $\mu$ from the variables in $\mathbf{r}$
  to elements of $\Delta^{\Hmc}$ such that $\mu(x) = \sigma(x)^{\Hmc}$ and $\Hmc,\mu\models V_{j}$
  for some $1\leq j \leq n$. Thus, $\Hmc\models\sigma(V_{j})$ and, hence, $\Hmc\models\A_{j}$ for
  some $1\leq j \leq n$.

  Since \A has a model, the $\bot$-rule is not applicable.
   
  If the $\approx$-rule is applicable, we have that $\Hmc\models s\approx t \in \A$ and, hence,
  $s^{\Hmc}=t^{\Hmc}$. Thus, $\Hmc$ also models $\Amc_{1}\coloneqq\mathsf{merge}_{\A}(s \to t)$ or
  $\Amc_{1}\coloneqq\mathsf{merge}_{\A}(t \to s)$. 
  %
  For the \textit{NI}-rule, it is analogous to the $\approx$-rule.

  If the $\geq$-rule is applicable, we have that $\atleast{n}{r}{B}(s)\in\A$. Since $\Hmc\models\A$,
  there exist $d_{1}, \dots, d_{n} \in B^{\Hmc}$ with $(s^{\Hmc},d_{i})\in r^{\Hmc}$. We define $\Hmc'$
  like \Hmc, but additionally set $t_{i}^{\Hmc'} = d_{i}$, where $t_{i}$ is the fresh successor of
  $c$ introduced by the $\geq$-rule. Hence, $\Hmc'$ models $\A_{1}$ and is essentially equal to
  \Hmc.

  Assume that the \textit{Hyp}-rule is applicable for $\mathbf{r} = U_{1} \land\dots\land U_{m} \to
  V_{1} \lor\dots\lor V_{n}\in\Cmc$. Then there is a mapping $\sigma$ from the variables in
  $\mathbf{r}$ to the individuals in \A such that $\sigma(U_{i})\in\A$ and $\sigma(V_{j})\notin\A$,
  for each $1\leq i \leq m$, $1\leq j \leq n$. Since $\Hmc\models\mathbf{r}$, there exists mapping
  $\mu$ from the variables in $\mathbf{r}$ to elements of $\Delta^{\Hmc}$ such that $\mu(x) =
  \sigma(x)^{\Hmc}$ and $\Hmc,\mu\models V_{j}$ for some $1\leq j \leq n$. Thus,
  $\Hmc\models\sigma(V_{j})$ and, hence, $\Hmc\models\A_{j}$ for some $1\leq j \leq n$.
\end{proof}

Similar as for a set of restricted types \Xmc where we defined admissibility (see
Definition~\ref{def:admissibility}) to assure that the corresponding o-axioms `fit together', we
define the admissibility of an ABox.

\begin{definition}[Admissibility of an ABox]\label{def:admissibility-of-abox}
  Let \A be an \LM-ABox over \Msig and let \RO be an object RBox. W.l.o.g., we assume that the meta individuals
  occurring in \A are $c_{1}$, \dots, $c_{k}$. We call \A \emph{admissible} if there exist
  \Osig-interpretations $\I_{1} = (\Delta, \cdot^{\I_{1}})$, \dots,
  $\I_{k} = (\Delta, \cdot^{\I_{k}})$ such that
  \begin{itemize}
  \item $x^{\I_{i}} = x^{\I_{j}}$ for all $x \in \OCR \cup \ORR \cup \OI$ and all
    $i,j\in\{1,\dots,k\}$, and
  \item every $\I_{i}$, $1 \leq i \leq k$, is a model of the \LO-ontology $\Omf_{c_{i}} = (\Omc_{c_{i}},
    \RO)$ over \Osig where
    \begin{align*}
      \Omc_{c_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in\Zpos{c_{i}}} \alpha \land
                     \bigwedge_{\bsf(\oalpha)\in\Zneg{c_{i}}} \alpha^{*} \\
      \intertext{with}
      \Zpos{c} & \coloneqq \{A\in\ran(\bsf) \mid   A(c)\in\A\} \text{ and} \\
      \Zneg{c} & \coloneqq \{A\in\ran(\bsf) \mid \lnot A(c)\in\A\}. \qedhere
    \end{align*}
  \end{itemize}
\end{definition}

Obviously, if \A is not admissible, no model \Hmc of \A will have an admissible set of occurring
restricted types $\Zmc_{\Hmc}$. If, for example,
$\{A_{\oax{B(a)}}(s), A_{\oax{B\sqsubseteq\bot}}(s)\}\subseteq\A$, then for any model \Hmc the
restricted type of $s^{\Hmc}$ will contain $A_{\oax{B(a)}}$ and
$A_{\oax{B\sqsubseteq\bot}}$. Hence, $\Zmc_{\Hmc}$ is not admissible.

\begin{lemma}\label{lem:A-admissible-iff-ZH-admissible}
  Let \Ap be a \LM-ABox over \Msig such that \Ap is complete and clash-free. Then,
  \Ap is admissible if and only if there exists a model \Hmc of \Ap such that $\Zmc_{\Hmc}$ is
  admissible.
\end{lemma}

\begin{proof}
  In the completeness proof for the Hypertableau Algorithm (see \cite{MoSH-JAIR09}, Lemma 6) a model
  $\Hmc_{\CA}$ for \CA is constructed by unraveling based on \Ap. Here, the domain elements are paths. We
  can extend this interpretation to $\Hmc_{\Ap}$ by additionally interpreting blockable individuals as follows:
  if $s$ is not blocked, then $s^{\Hmc_{\Ap}}\coloneqq \left[p\mid\frac{s}{s}\right]$ and if $s$ is
  blocked by $t$, then $s^{\Hmc_{\Ap}}\coloneqq \left[p\mid\frac{t}{s}\right]$ where $p$ is a path where
  $s$ does not occur. Hence, $\Hmc_{\Ap}$ is also a model of \Ap.

  W.l.o.g., we assume that the meta individuals occurring in \Ap are $c_{1}$, \dots, $c_{k}$.  For
  any interpretation \Hmc such that $\Hmc\models\Ap$, let
  $\Zmc_{\Hmc}=(Z_{1},\dots,Z_{k},Z_{k+1},\dots,Z_{\ell})$ such that
  $Z_{i}=\mathsf{type}_{\ran(b)}^{\Hmc}(c_{i}^{\Hmc})$ for $1\leq i\leq k$. Considering the
  conjunction of axioms as a set of conjuncts, we have that $\Omc_{c_{i}}\subseteq \Omc_{Z_{i}}$ where
  $\Omc_{c_{i}}$ (see Def.~\ref{def:admissibility-of-abox}) and $\Omc_{Z_{i}}$ (see
  Lem.~\ref{lem:admissibility-without-rigid}) are defined as
  \begin{align*}
    \Omc_{c_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in\Zpos{c_{i}}} \alpha \land
                     \bigwedge_{\bsf(\oalpha)\in\Zneg{c_{i}}} \alpha^{*}, \\
    \Omc_{Z_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in Z_i}\alpha\ \land
      \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus Z_i}\lnot\alpha.
  \end{align*}
  %
  If \Ap is not admissible, then $(Z_{1},\dots,Z_{k})$ cannot be admissible. Hence, $\Zmc_{\Hmc}$ is
  also not admissible.

  If \Ap is admissible, let $\I_{1},\dots,\I_{k}$ be the \Osig-interpretations modelling
  $\Omc_{c_{1}},\dots,\Omc_{c_{k}}$. For any
  $\bsf(\oalpha) \in \ran(\bsf) \setminus (\Zpos{c_{i}}\cup\Zneg{c_{i}})$, we have that $\I_{i}$ is
  either a model of $\Omc_{c_{i}}\land\alpha$ or $\Omc_{c_{i}}\land\lnot\alpha$.  For any concept
  assertion $A(c)$ with $A\in\MC$, $\Hmc_{\Ap}\models A(c)$ iff $A(c)\in\Ap$ by construction of
  $\Hmc_{\Ap}$. However, if both $A(c)\notin\Ap$ and $\lnot A(c)\notin\Ap$, then $\Hmc_{\Ap}'$ which
  is equal to $\Hmc_{\Ap}$ except that
  $A^{\Hmc_{\Ap}'} \coloneqq A^{\Hmc_{\Ap}} \cup \{c^{\Hmc_{\Ap}}\}$ also models \Ap and
  $A(c)$. Note here, that $\Hmc_{\Ap}'$ also models \A, but not necessarily \Cmc anymore.
  % 
  We define $\Hmc^{*}$ such that for all $\bsf(\oalpha) \in \ran(\bsf) \setminus
  (\Zpos{c_{i}}\cup\Zneg{c_{i}})$ with $\I_{i}\models\Omc_{c_{i}}\land\alpha$ we set
  $\bsf(\oalpha)^{\Hmc^{*}} \coloneqq \bsf(\oalpha)^{\Hmc_{\Ap}} \cup \{c_{i}^{\Hmc_{\Ap}}\}$. Thus,
  $\I_{i}\models\Omc_{Z_{i}}$ where $Z_{i} = \mathsf{type}_{\ran(b)}^{\Hmc^{*}}(c_{i})$. Since
  $\Zmc_{\Hmc^{*}} = (Z_{1},\dots,Z_{k})$, $\Zmc_{\Hmc^{*}}$ is admissible.
  % 
  % 
  % For any DL BKB \Bmf and DL axiom $\alpha$ it holds that if \Bmf is consistent then
  % either $\Bmf\land\alpha$ or $\Bmf\land\lnot\alpha$ is also consistent.
  % 
  % Let \Ap be admissible and $c_{1}$, \dots, $c_{k}$ the meta individuals occurring in \A. We define
  % $\HH$ such that
  % \begin{align*}
  %   \Delta^{\Hmc} & = \{c_{1}, \dots, c_{k}\}, \\
  %   c_{i}^{\Hmc} & = c_{i} \text{ for each individual $c_{i}$ that occurs in an assertion in \Ap}, \\
  %   A^{\Hmc} & = \{c_{i} \in \Delta^{\Hmc} \mid A(c_{i}) \in \Ap\} \text{ for all $A\in\MC$, and} \\
  %   r^{\Hmc} & = \{(c_{i}, c_{j}) \in \Delta^{\Hmc} \times \Delta^{\Hmc} \mid r(c_{i}, c_{j}) \in
  %   \Ap\} \text{ for all $r \in \MR$}.
  % \end{align*}
  % Clearly, \Hmc models all role assertions and all concept assertions of the form $A(c)$ with
  % $A\in\MC$ that occur in \Ap. For concept assertions of the form $\lnot A(c)$, we know that
  % $A(c)\notin\Ap$, since \Ap is clash-free and thus the $\bot$-rule was never applied. Therefore, we
  % have that $\Hmc\models\lnot A(c)$. For any assertion of the form $(\atleast{n}{r}{B})(c)$, since
  % the $\leq$-rule is not applicable, there exist
  % 
  % \begin{itemize}
  % \item Since \A clash-free, there exists model \Hmc
  % \item \A admissible -> interpretations $\I_{1}$, \dots, $\I_{k}$ 
  % \item in \A are only literal assertions, equality ($s\approx t$) or at-least assertions
  % \item since \A is complete, for at-least assertions there exists necessary successors (with
  %   respective types)
  % \item in admissibility for \ZH we have to look at all $A_{\oalpha}$
  % \end{itemize}
  % 
  % \todo[inline]{ausformulierung und andere richtung fehlt noch}
\end{proof}


Note that this lemma yields that for an inadmissible ABox \Ap there exists no model of \CA and \Ap
with admissible types. Thus, due to Lemma~\ref{lem:model-has-abox} we know that if all ABoxes which
label leaf nodes in a derivation are inadmissible, then \CA is inconsistent.
%
However, the converse does not hold. If \Ap is admissible and clash-free, it is still possible that
there exists no model \Hmc of \CA and \Ap such that \ZH is admissible as the following example
shows.

\begin{example}
  Let $\Bmfex = (\Bmcex,\emptyset,\emptyset)$ with $\Bmcex = \lnot C(s) \land \oax{\lnot A(a)} \sqsubseteq
  C \land \lnot C \sqsubseteq \oax{A\sqsubseteq\bot}$ be an \ALCALC-ontology. Then,
  \begin{align*}
    \Bmfbex & = \big(\lnot C(s) \quad\land\quad 
              A_{\oax{\lnot A(a)}} \sqsubseteq C \quad\land\quad
              \lnot C \sqsubseteq A_{\oax{A\sqsubseteq\bot}} ,\quad \emptyset\big)\\
    \intertext{is the outer abstraction of \Bmfex. The normalization and clausification of \Bmfbex yields \CAex with}
    \Cex & = \{A_{\oax{\lnot A(a)}}(x) \to C(x), \quad \top\to C(x) \lor
           A_{\oax{A\sqsubseteq\bot}}(x)\},\\
    \Aex & = \{\lnot C(s)\}.\\
    \intertext{Any derivation of \CAex produces a leaf node labelled with}
    \Ap & = \{\lnot C(s),\ A_{\oax{A\sqsubseteq\bot}}(s)\}.
  \end{align*}
  Clearly, \Ap is admissible and in any model \HH of \Ap such that \ZH is admissible there exists
  $d\in\Delta^{\Hmc}$ with $s^{\Hmc} = d$ and $d \in {A_{\oax{A\sqsubseteq\bot}}}^{\Hmc}$. For \ZH
  to be admissible, we know that $X = \{A_{\oax{A\sqsubseteq\bot}}\} \notin \ZH$ since
  $\Omc_{X} = A \sqsubseteq \bot \ \land\ \lnot(\lnot A(a))$ is not consistent . Thus, we also have
  $d \in {A_{\oax{\lnot A(a)}}}^{\Hmc}$. Because of $A_{\oax{\lnot A(a)}}(x) \to C(x)$ and
  $\lnot C(s)$, we know that \Hmc cannot be model of \CAex. In fact, there
  exists no model $\Hmc'$ of \CAex such that $\Zmc_{\Hmc'}$ is admissible
  since \Bmfex is inconsistent.
\end{example}

The above example illustrates that there can exist implicitly negated concept assertions in a
complete, clash-free meta ABox \Ap, i.e.\ concept assertions that would cause a clash if added to
the ABox. In the proof of Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, we may need to add certain
concept assertions in order to assure the admissibility. To avoid adding concept assertions which
cause a clash, we add special DL-clauses to \Cmc. Since for every context $c\in\Cbb$ an object
axiom~$\alpha$ is either modelled by $\I_{c}$ or not, we can assume w.l.o.g.\ that
$c\in\bsf(\oalpha)^{\Jb}$ or $c\in\bsf(\oax{\alpha^{*}})^{\Jb}$. Thus, we can add the DL-clause
$\top\to\bsf(\oalpha)(x) \lor \bsf(\oax{\alpha^{*}})(x)$ without adding any logical consequences.

\begin{definition}[Repletion of DL-clauses]
  Let \Cmc be a set of \LM-clauses over \Msig and \A an \LM-ABox over \Msig. The \emph{repletion of
    \Cmc} is obtained from \Cmc by adding the \LM-clause
  \begin{align*}
    \top\to\ A_{\oalpha}(x)\ \lor\ A_{\oax{\alpha^{*}}}(x)
  \end{align*}
 to \Cmc for each
  $A_{\oalpha} \in \ran(\bsf)$ that occurs in \Cmc or \A, where
  $A_{\oax{\alpha^{*}}} = \bsf(\alpha^{*})$ and $\alpha^{*}$ is the weakly negation of $\alpha$.

  For an \LM-ontology \Omcb, the \emph{repleted clausification} is obtained from the clausification \CA
  of \Omcb where \Cmc is replaced with its repletion.
\end{definition}

In the proof of Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, we needed $\Hmc^{*}$ which models
$A_{\oalpha}(c)$ where $A_{\oalpha}(c)\notin\A'$ and $\I_{i}\models\Bmc_{c_{i}}\land\alpha$.
%
If \Cmc is repleted and $A_{\oalpha}(c)\notin\Ap$, we have that
$A_{\oax{\alpha^{*}}}(c)\in\Ap$. Hence, we know that $\I_{i}\models\alpha^{*}$ and, due to
Lemma~\ref{lem:weakly-negation-inconsistent}, $\I_{i}\not\models\alpha$. Thus,$\Hmc^{*}$ is not
needed anymore.

To sum up we refine Algorithm~\ref{alg:1}, so it can be used with the hypertableau calculus. The
algorithm is depicted in Algorithm~\ref{alg:2}, where $\Omc_{c_{i}}$ is defined as in
Definition~\ref{def:admissibility-of-abox}. Instead
of enumerating all models of $\smash{\Omf^{\bsf}}$ up to essential equality, we traverse the clash-free, complete
ABoxes in a derivation of \CA and check whether there is an admissible ABox among them. To check
admissibility, we reuse the results of Section~\ref{sec:blackbox-approach}. Thus, $\Omc_{\Ap}$ is
defined analogous to Definition~\ref{def:renaming}. The next two lemmata show that
Algorithm~\ref{alg:2} is sound and complete. 

\IncMargin{1em}
\RestyleAlgo{ruled}
\begin{algorithm}[t]
  \SetAlgoVlined
  \setstretch{1.1}
  \DontPrintSemicolon
  \SetKwData{true}{true}
  \SetKwData{false}{false}
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  %
  \Input{\LMLO-ontology \Omf}
  \Output{\true if \Omf is consistent, \false otherwise}
  \BlankLine
  %
  Preprocessing (results in \CA):\;
  1. Elimination of transitivity axioms, normalization, clausification\;
  2. Repletion of DL-clauses\;
  %
  \BlankLine
  Let $(T,\lambda)$ be any derivation for \CA\;
  $\Amf \coloneqq \{ \Ap \mid \text{there exists a leaf node in $(T,\lambda)$ that is labelled with \Ap}\}$\;
  \For{$\Ap \in \Amf$}{
    \If{\Ap is clash-free}{
      \eIf{\Omf contains rigid names}{
        \If{($\Omc_{\Ap}, \RO')$ is consistent}{
          \vspace{0.5ex}\Return{\true}
        }
      }{
        Let $\{c_{1},\dots,c_{k}\}$ be the individuals occurring in \Ap\;
        \If{$(\Omc_{c_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$}{
          \vspace{0.5ex}\Return{\true}
        }
      }
    }
  }
  \Return{false}
  \caption{Algorithm for checking consistency of \LMLO-ontology \Omf with Hypertableau}\label{alg:2}
\end{algorithm}

\begin{lemma}[Soundness]
  Let \Omf be an \LMLO-ontology. If Algorithm~\ref{alg:2} returns \false, then \Omf is inconsistent.
\end{lemma}
\begin{proof}
  If Algorithm~\ref{alg:2} returns \false, then for any derivation all complete ABoxes either
  contain a clash or are not admissible. Assume that \Omf is consistent. Then, by
  Lemma~\ref{lem:consistant-and-admissible-types}, we know that there would be some \Msig-interpretation \Hmc
  that models \CA with $\Zmc_{\Hmc}$ being admissible. Due to
  Lemmata~\ref{lem:model-has-abox} and~\ref{lem:A-admissible-iff-ZH-admissible}, there would be
  some complete, clash-free ABox \Ap which is admissible. This is a contradiction and, hence, \Omf
  is inconsistent.
\end{proof}

\begin{lemma}[Completeness]
  Let \Omf be an \LMLO-ontology. If Algorithm~\ref{alg:2} returns \true, then \Omf is consistent.
  %
  % , \Omcb its outer abstraction and \CA the repleted clausification of
  % \Omcb. 
  % %
  % Then, if a derivation exists such that a leaf node is labelled with a clash-free and admissible
  % ABox \Ap, then \Omc is satisfiable.
\end{lemma}

\begin{proof}
  If Algorithm~\ref{alg:2} returns \true, then there exists some clash-free, complete ABox \Ap in
  any derivation of \CA such that \Ap is admissible. Due to
  Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, there exists an \Msig-interpretation \Hmc such
  that $\Hmc\models\Ap$ and $\Zmc_{\Hmc}$ is admissible.  If $\bsf(\oax{\alpha})(c)\notin\Ap$, then
  due to the repletion we know that $\bsf(\oax{\alpha^{*}})(c)\in\Ap$. Since $\alpha\land\alpha^{*}$
  is inconsistent, we have that $\bsf(\oalpha)\notin\type_{\ran(\bsf)}^{\Hmc}(c^{\Hmc})$.
  Therefore, in the construction of $\Hmc$ no additional assertions must be assumed and \Hmc also
  models \CA.
  %
  Hence, by Lemma~\ref{lem:consistant-and-admissible-types}, \Omf is consistent.
\end{proof}

However, introducing a lot of disjunctive DL-clauses to \Cmc increases the non-determinism
tremendously. 

%  When constructing a model for \CA out of \Ap ... 

% Another preprocessing step for the DL clauses can eliminate these implicit negated concept
% assertions. Question whether $\Ap \cup \{A_{\oalpha}(s)\}$ causes a clash. Either

% \begin{definition}[Elimination of implicit negative concept assertions]
%   Let \Cmc be a set of DL clauses.
% \end{definition}

% \begin{lemma}
%   A set \Cmc of DL clauses is satisfiable if and only if $\Omega(\Cmc)$ is satisfiable.
% \end{lemma}


% \vspace{3cm}

% \noindent\rule{\textwidth}{5pt}


% For our calculus another property is important. If $(\Cmc, \A)$ is satisfiable, then
% for every model~\Hmc of $(\Cmc, \A)$ and for every derivation of $(\Cmc, \A)$ there is a leaf node
% labelled with a clash-free ABox~$\A'$ such that the assertions in~$\A'$ induce the types
% occurring in~\Hmc.

% First, we introduce some notions.\todo{rephrase}

% \begin{definition}[Induced types]
%   Let \A be a meta ABox and $c$ be a meta individual occurring in \A. Then the sets of \emph{positive} and \emph{negative asserted referring concepts
%   \Zpos{c}} and \emph{\Zneg{c} for $c$} are defined as
%   \begin{align*}
%     \Zpos{c} & \coloneqq \{A_{\oalpha} \mid A_{\oalpha}(c) \in \A \text{ and } A_{\oalpha} \in
%                     \ran(\bsf)\} \text{ and} \\
%     \Zneg{c} & \coloneqq \{A_{\oalpha} \mid \lnot A_{\oalpha}(c) \in \A \text{ and } A_{\oalpha} \in
%                     \ran(\bsf)\}.
%   \end{align*}
%   The \emph{by $c$ induced restricted types \types{c}} are defined as follows:
%   \begin{align*}
%     Y \in \types{c} \textIff Y \subseteq \ran(\bsf)\text{, }\Zpos{c} \subseteq Y \text{ and } \Zneg{c}
%     \subseteq ran(\bsf) \setminus Y.
%   \end{align*}
%   The \emph{set of induced restricted types \typesA} is defined as $\typesA \coloneqq
%   \bigcup_{c\in\MI(\A)} \types{c}$.
% \end{definition}

% \begin{lemma}\label{lem:ABox-induces-types-in-model}
%   For each model \HH of $(\Cmc, \A)$ with $\Zmc_{\Hmc} \coloneqq \{\mathsf{type}_{\ran(b)}^{\Hmc}(d)
%   \mid d \in \Delta^{\Hmc}\}$ in any derivation of $(\Cmc, \A)$ there exists a leaf node labelled
%   with a clash-free ABox $\A'$ such that for each restricted type $Z\in\Zmc_{\Hmc}$ there exists
%   $c\in\MI$ with $\Zpos[\A']{c} \subseteq Z$ and $\Zneg[\A']{c} \subseteq \ran(\bsf) \setminus Z$ where
%   \begin{align*}
%     \Zpos[\A']{c} & \coloneqq \{A_{\oalpha} \mid A_{\oalpha}(c) \in \A' \text{ and } A_{\oalpha} \in
%                     \ran(\bsf)\}, \\
%     \Zneg[\A']{c} & \coloneqq \{A_{\oalpha} \mid \lnot A_{\oalpha}(c) \in \A' \text{ and } A_{\oalpha} \in
%                     \ran(\bsf)\}.
%   \end{align*}
  
% \end{lemma}


% \missingproof

%  If there exists a
% derivation for $(\Cmc, \Amc)$ with a leaf node labelled with a clash-free ABox $\A'$, then not only a
% model \I of $(\Cmc,\A)$ can be constructed from $\A'$, but the types occurring in \I also occur in
% $\A'$.

% \begin{lemma}
%   If a derivation for $(\Cmc, \A)$ exists in which some leaf node is labelled with a clash-free ABox
%   $\A'$, then for each $Z \in \Zmc_{\I}$
% \end{lemma}

% In Algorithm~\ref{alg:1} we need to enumerate over all essentially different models. By
% Lemma~\ref{lem:ABox-induces-types-in-model} we know that it is sufficient to enumerate

% \todo[inline,color=yellow]{}

% ... as the following example shows. \Zmf \Amf

% \Amf \Bmf \Cmf \Dmf \Emf \Fmf \Gmf \Hmf \Imf \Jmf \Kmf \Lmf \Mmf \Nmf \Omf \Pmf \Qmf \Rmf \Smf \Tmf
% \Umf \Vmf \Wmf \Xmf \Ymf \Zmf

% \Amc \Bmc \Cmc \Dmc \Emc \Cmc \Gmc \Hmc \Imc \Jmc \Kmc \Lmc \Mmc \Nmc \Omc \Pmc \Qmc \Rmc \Smc \Tmc
% \Umc \Vmc \Wmc \Xmc \Ymc \Zmc

% \begin{example}
  
% \end{example}


% \noindent\rule{\textwidth}{5pt}

% Therefore (Due to Lemma ??) when enumerating all essentially equal models, it is enough to check all
% clash-free leafs of a derivation.


% If a leaf in a derivation is labelled with a clash-free ABox \A, it represents premodel. With
% well-known technique of unraveling \todo{citation} a model of $(\Cmc, \A)$ can be
% constructed. 
% \todo[inline]{one premodel can represent more than one essential different model of $(\Cmc, \A)$.}


\section{Implementing JConHT}
\label{sec:implementing-jconht}

We implemented Algorithm~\ref{alg:2} in a reasoner called \emph{JConHT} -- a \emph{J}ava-implemented
\emph{Con}text description logic reasoner based on \emph{H}ermi\emph{T}. Like HermiT, it is an OWL
compliant reasoner implementing the \textsf{OWLReasoner} interface of the OWL API.

Nearly all reasoners use the Web Ontology Language (OWL) in order to represent an ontology.
However, in general OWL cannot express contextualized knowledge. In~\cite{BoGH-ISWC03}, Bouquet et
al. introduce C-OWL, an extension of the OWL syntax and semantics to allow for the representation of
contextual ontologies. But their view differs quite strongly on what a context is from our approach,
so we cannot use C-OWL. Anyway, HermiT would not support C-OWL.

But OWL has other means to enrich an ontology with more information due to \emph{OWL
  annotations}. Annotations associate information with an ontology, for example the ontology
creator's name. But also concept, role and individual names or axioms can be annotated. We use the
outer abstraction of an ontology which is a `normal' DL-ontology and define the connection between
an abstracted concept name and the corresponding o-axiom via a special OWL annotation. We decided to
use the predefined OWL annotation property \rdfsIsDefinedBy for that purpose. We simply
annotate the o-axiom $\alpha$ with the abstracted meta concept name $A_{\oalpha}$.
%
Let us again consider Example~\ref{ex:outer-abstraction}:
\begin{example}\label{ex:outer-abstraction-as-OWL}
  Let \Omc be the \ALCALC-ontology
  \begin{align*}
    \Omc \coloneqq (C\sqsubseteq(\oax{A\sqsubseteq\bot})\ \land\ (C\sqcap\oax{A(a)})(c),\ \emptyset,\ \emptyset).
  \end{align*}
Then \Omc looks in OWL 2 functional syntax as follows:

\smallskip\noindent
\verb+SubclassOf(cls:C cls:A_ASubBot)+\\
\verb+ClassAssertion(ObjectIntersectionOf(cls:C cls:A_Aa) ind:c)+\\
\verb+SubclassOf(Annotation(rdfs:isDefinedBy cls:A_ASubBot) cls:A owl:Bottom)+\\
\verb+ClassAssertion(Annotation(rdfs:isDefinedBy cls:A_Aa) cls:A ind:a)+
\end{example}

Furthermore, in practical applications we often encounter object axioms that must hold independently
of any context. These so-called \emph{global object axioms} are of the form
$\top \sqsubseteq \oalpha$. Using the above approach would introduce a new abstracted meta concept
for each such axiom and, thus, unnecessarily bloat the OWL ontology. Instead we decided to handle
another OWL annotation with a special meaning: \rdfsLabelGlobal.
%
At last, we need to specify which concept and role names are rigid. Since only the ontology as whole
or single axioms can be annotated, we use annotated declaration axioms. Declaration axioms do not
affect the consequences of an OWL 2 ontology, they simply declare the existence of an entity and
associate it with an entity type. We again use a special OWL annotation: \rdfsLabelRigid.
%
Consider a light variation of example~\ref{ex:outer-abstraction-as-OWL}:

\begin{example}\label{ex:outer-abstraction-as-OWL-w-global}
  Let \Omc be the \ALCALC-ontology
  \begin{align*}
    \Omc \coloneqq (\top\sqsubseteq(\oax{A\sqsubseteq\bot})\ \land\ \oax{A(a)}(c),\ \emptyset,\ \emptyset).
  \end{align*}
  with $A\in\OCR$. Then \Omc looks in OWL 2 functional syntax as follows:

\smallskip\noindent
\verb+Declaration(Annotation(rdfs:label "rigid") Class (cls:A))+\\
\verb+ClassAssertion(cls:A_Aa ind:c)+\\
\verb+ClassAssertion(Annotation(rdfs:isDefinedBy cls:A_Aa) cls:A ind:a)+\\
\verb+SubclassOf(Annotation(rdfs:label "objectGlobal") cls:A owl:Bottom)+
\end{example}

We next present how we implement our algorithm. The main components that we discuss are the
\texttt{ContextOntology}, \texttt{ContextReasoner} and \texttt{ContextTableau} classes. 

The \texttt{ContextOntology} class stores the specially formatted input OWL ontology as
\textsf{rootOntology}. The constructor additionally extracts the outer abstraction, i.e.\ all
logical OWL axioms in \textsf{rootOntology} that are not annotated with \rdfsIsDefinedBy or
\rdfsLabelGlobal, and stores the connection of the abstracted concept names and corresponding the
o-axioms in a hash map.  If necessary, the repletion of the DL-clauses is handled here, too. Since
we cannot directly add DL-clauses at this stage, we add the axiom
$\top\sqsubseteq \bsf(\oalpha)\sqcup\bsf(\oax{\alpha^{*}})$, which is then transformed into the
according DL-clause.
%
The class also provides a method \mbox{\textsf{getMetaOntology()}} to return the outer abstraction.
A separate method allows to retrieve all global object axioms as a stream of \textsf{OWLAxiom}s.
%
If no rigid names are present, the method \textsf{getObjectOntology($X_{1}$)} returns an OWL
ontology which is an conjunction of all global object axioms, all object axioms corresponding to the
positively asserted abstracted meta concepts in $X_{1}$ and the weakly negation of all object axioms
corresponding to the negatively asserted abstracted meta concepts in $X_{1}$. Here, $X_{1}$ is an
instance of the class \texttt{RestrictedType}, essentially a pair $(\Xpos,\Xneg)$ of sets of
positively and negatively asserted, abstracted concept names.
%
If rigid names are present, \textsf{getObjectOntology($X_{1},\dots,X_{k}$)} returns the overall OWL
ontology after applying the renaming technique to the the single axioms according to
Definition~\ref{def:renaming}.  The output of \texttt{getObjectOntology($\cdot$)} is used to check
admissibility.


The class \texttt{ContextReasoner} is a subclass of HermiT's \texttt{Reasoner} class and thereby
implements the \texttt{OWLReasoner} interface of the OWL API. Compared to HermiT's \texttt{Reasoner}
it only changes the tableau to be a \texttt{ContextTableau}.

The main parts of our algorithm are implemented in the \texttt{ContextTableau} class which is a
subclass of HermiT's \texttt{Tableau} class.  In HermiT, the \texttt{runCalculus()} method of
\texttt{Tableau} runs the hypertableau algorithm trying to build a model of \CA.  Its
\texttt{ExtensionManager} contains the set of assertions of an ABox that labels a node in a
derivation. When no derivation rule is applicable and if the \texttt{ExtensionManager} is
clash-free, it contains a pre-model, i.e. the set of assertions from which through unraveling a
model of \CA can be constructed, proving the consistency of \CA.  If the \texttt{ExtensionManager}
contains a clash, backtracking is triggered and the next leaf in the derivation is considered.

We override \texttt{runCalculus()} in \texttt{ContextTableau} such that it also returns true if and
only if the input context ontology is consistent.  Therefore we implement an method
\texttt{consistentInterpretations()} that returns a stream of models of the meta ontology, i.e.\ the
outer abstraction of the input ontology.  It internally uses \texttt{Tableau}'s \texttt{runCalculus()}
to calculate the models. It reads off the pre-model of the \texttt{ExtensionManager} and sets a
clash afterwards, so that for the next stream element \texttt{Tableau}'s \texttt{runCalculus()}
calculates the next pre-model.

This stream of pre-models is filtered for admissible 


% As every relevant description logic reasoner uses the Web Ontology Language (OWL), we have to adapt
% our general setting in order to stay compliant with the usual assumptions. Most importantly OWL does
% not make the unique name assumption. In contrast to the arguments given in section
% \ref{sec:description-logics} in favour of the UNA, individual names are rather seen as an label for
% an object in OWL. Especially if one wants to merge two different ontologies talking about the same
% topic, it seems quite natural to be able to state that two individual names actually represent the
% same object. Furthermore, OWL2 allows for a so-called \emph{Individual Inequality Axiom} which can be
% used to axiomatize the unique name assumption if needed.

% As a design decision we chose to also neglect the UNA in our case. Consequently, we then also drop
% the rigid individual assumption we made in chapter \ref{cha:context-dls}. When individual names are
% seen as labels, of course, these could change from context to context. To be also able to express
% rigid individuals we analogously introduce the set of \emph{rigid individual names }$\OIR \subseteq
% \OI$. Straightforward we adapt the notions of a nested interpretation and of admissibility.

% \begin{definition}[Nested interpretation (without RIA)]\label{def:nested-interpretation-without-ria}
% A \emph{nested interpretation} is a tuple \JJ, where \Cbb is a non-empty set (called
%   \emph{contexts}) and $(\Cbb,\cdot^\J)$ is an \Msig-interpretation.
%   %
%   Moreover, for every $c\in\Cbb$, $\I_c\coloneqq(\Delta^{\J},\cdot^{\I_c})$ is an \Osig-interpretation
%   such that we have for all $c,c'\in\Cbb$ that $x^{\I_{c}}=x^{\I_{c'}}$ for every
%   $x\in\OIR\cup\OCR\cup\ORR$.
% \end{definition}

% \begin{definition}[Admissibility (without RIA)]\label{def:admissibility-without-ria}
%   Let $\Xmc=\{X_1,~\dots,\ X_k\}\subseteq\powerset{\ran(\bsf)}$.  We call \Xmc \emph{admissible} if
%   there exist \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1})$,~\dots,
%   $\I_k=(\Delta,\cdot^{\I_k})$ such that
%   \begin{enumerate}
%   \item $x^{\I_i}=x^{\I_j}$ for all $x\in\OIR\cup\OCR\cup\ORR$ and all $i,j\in\{1,\dots,k\}$, and
%   \item every $\I_i$, $1\le i\le k$, is a model of the \LO-BKB $\Bmf_{X_{i}}= (\B_{X_i},\RO)$
%     over~\Osig where
%     \begin{align*}
%       \B_{X_i}:=\bigwedge_{\bsf(\oalpha)\in X_i}\alpha\ \land
%       \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha.
%     \end{align*}
%   \end{enumerate}
%   \vspace{-1.7\baselineskip}
% \end{definition}




% \todo[inline]{What happens with complexity results?}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% reftex-default-bibliography: ("../references.bib")
%%% End:

%  LocalWords:  performant axiomatize iff logics clausification inline ABox ontologies workflow DL
%  LocalWords:  bijection subtasks nominals conformant hypertableau DLs Konclude API HermiT ABoxes
%  LocalWords:  blockable Preprocessing OWLReasoner et al ava
