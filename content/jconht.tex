
\addtocontents{toc}{\protect\null}
% avoid underfull vbox in toc
% https://tex.stackexchange.com/questions/453341/underfull-vbox-in-table-of-contents

\chapter{JConHT -- A \texorpdfstring{\SHOIQSHOIQ}{SHOIQ[SHOIQ]} Reasoner}
\label{cha:jconht}

In the last chapter, we presented a mapping for role-based models into contextualised description
logic ontologies. This step can be automated which helps the automated processing and investigation
of role-based models. But to obtain a full automation we need a reasoner that is capable of handling
these ontologies, and can check the consistency automatically.

Since the translation for role-based models produces \LMLO-ontologies, i.e.\ conjunctions of meta
axioms, we will only consider \LMLO-ontologies. Throughout this chapter, let $\Omf=(\Omc,\RM,\RO)$
denote a \SHOIQSHOIQ-ontology and let \bsf denote the bijection as in
Definition~\ref{def:outer-abstraction}. Hence, \Ob denotes the outer abstraction of \Omc. We also
remind the reader that the \emph{restricted type} is the $\ran(\bsf)$-type (see
Definition~\ref{def:int-respects-D}) of some element and thus a subset of $\ran(b)$.

In this chapter, we present a practical algorithm to check consistency.  Furthermore, we implemented
this algorithm and give details on the design of the implementation.  Since internally, this
algorithm only calls standard DL consistency checks, we can reuse existing, highly optimised DL
reasoners.

\section{A Black-Box Approach}
\label{sec:blackbox-approach}

In Section~\ref{sec:complexity-consis-problem}, we showed that we can reduce the consistency problem
of \LMLO to two separate decision problems. Now, the general idea for an implementation is to use
performant reasoners as black-boxes for these subtasks.
%
In this section we discuss how the two subtasks, namely admissibility of a set~\Xmc and outer
consistency w.r.t.~\Xmc, can be reduced to standard reasoning tasks.


\subsection{Admissibility}
\label{sec:admissibility}

In the definition of admissibility (Definition~\ref{def:admissibility}), where we define $\Bmc_{X_{i}}$,
we require negated o-axioms. Negated axioms, especially negated GCIs, are usually not supported by
classical description logic reasoners. Therefore, we introduce the notion of \emph{weakly negated
  axioms}.

\begin{definition}[Weakly negated axioms]
  Let $\alpha$ be an axiom over \Nsig, then the \emph{weakly negated axiom $\alpha^{*}$} is defined
  as follows:
  \begin{itemize}
  \item if $\alpha = C \sqsubseteq D$, then $\alpha^{*} \coloneqq (C \sqcap \lnot D)(x)$ where $x$
    is a fresh variable,
  \item if $\alpha = C(a)$, then $\alpha^{*} \coloneqq (\lnot C)(a)$, and
%  \item if $\alpha = r(a,b)$, then $\alpha^{*} \coloneqq \lnot r(a,b)$, and
  \item for all other $\alpha$, $\alpha^{*} \coloneqq \lnot \alpha$. \qedhere
  \end{itemize}
\end{definition}

Note here, that for concept assertions the negation of the axiom $\lnot\alpha$ and weakly negated
axiom $\alpha^{*}$ are semantically equal, but not syntactical since $\lnot\alpha$ uses axiom
negation, while $\alpha^{*}$ only requires concept negation. Furthermore, in the presence of
nominals we could rewrite a negated role assertion of the form $\lnot r(a,b)$ as
$(\lnot\exists r.\{b\})(a)$. But as OWL reasoners in general support negated role assertions, we
keep $\lnot r(a,b)$.  Moreover, this definition reflects that $\alpha\land\alpha^{*}$ is
inconsistent, but not that $\I\models\alpha\lor\alpha^{*}$ for all interpretations \I.

\begin{lemma}\label{lem:weakly-negation-inconsistent}
  Let $\alpha$ be an axiom, and let \I be an interpretation. Then,
  \begin{enumerate}
  \item $\alpha\land\alpha^{*}$ is inconsistent, and
  \item if $\I\not\models\alpha$, then there exists an extension $\I'$ of $\I$ such that $\I'\models\alpha^{*}$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Let $\alpha = C \sqsubseteq D$ and $\alpha^{*} = (C \sqcup \lnot D)(x_{\mathsf{new}})$. Assume
  that $\I \models \alpha$ and $\I \models C(x_{\mathsf{new}})$.  Then, we know that
  ${x_{\mathsf{new}}}^{\I} \in C^{\I} \subseteq D^{\I}$. Thus we have
  ${x_{\mathsf{new}}}^{\I} \in D^{\I}$ and clearly
  ${x_{\mathsf{new}}}^{\I} \notin (C \sqcap \lnot D)^{\I}$. Hence,
  $C \sqsubseteq D \land (C \sqcap \lnot D)(x_{\mathsf{new}})$ is inconsistent.

  If $\I\not\models C \sqsubseteq D$, then there exists $d\in\Delta^{\I}$ such that
  $d \in C^{\I} \cap (\lnot D)^{\I}$. Then, the interpretation~$\I'$, obtained from \I by setting
  ${x_{\mathsf{new}}}^{\I'} \coloneqq d$, models $\alpha^{*}$.

  For the other axioms, the weakly negated axiom is defined as the normally negated axiom and the
  claim follows directly from the definition of $\models$ (see Definition
  \ref{def:semantics-of-axioms}).
\end{proof}

To check admissibility of a set of types, we distinguish whether or not rigid names are present. In
the latter case, i.e.\ $\OCR=\ORR=\emptyset$, the first condition of
Definition~\ref{def:admissibility} is always fulfilled. W.l.o.g., we can interpret the individual
names in the same way in every interpretation. Therefore, we can check each $\Bmf_{X_{i}}$ separately. We
show that it is sufficient to consider the weakly negated axioms.

% \begin{definition}[Sets of positive and negative induced o-axioms]
%   Let $\Xmc = \{X_{1}, \ldots, X_{k}\}$ be a set of restricted types. Then, the \emph{sets of
%     positive induced o-axioms $\Xposi$} are defined as
%   \begin{align*}
%     \Xposi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in X_{i}\}.\\
%   \intertext{The \emph{sets of negative induced o-axioms \Xnegi} are defined as}
%     \Xnegi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\}.\qedhere
%   \end{align*}
% \end{definition}


\begin{lemma}\label{lem:admissibility-without-rigid}
  If no rigid names are present, i.e.\ $\OCR=\ORR=\emptyset$, the set $\Xmc = \{X_{1}, \ldots, X_{k}\}$ of restricted types is
  admissible iff $\Omf_{X_{i}} = (\Omc_{X_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$, where
  $\Omc_{X_{i}}$ is defined as
  \begin{align*}
    \Omc_{X_{i}}:=\bigwedge_{\bsf(\oax{\alpha})\in X_{i}}\alpha\ \land \bigwedge_{\bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}}\alpha^{*}.
  \end{align*}
\end{lemma}
\begin{proof}
  Assume that \Xmc is admissible. Then there exists \Osig-interpretations
  $\I_1=(\Delta,\cdot^{\I_1})$,~\dots, $\I_k=(\Delta,\cdot^{\I_k})$ such that every $\I_i$,
  $1\le i\le k$, is a model of $\Bmf_{X_{i}}$ where $\Bmf_{X_{i}}$ is defined as in
  Definition~\ref{def:admissibility}. 
  Let \Xposi and \Xnegi respectively denote the sets of positive and negative induced o-axioms
  \begin{align*}
    \Xposi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in X_{i}\}\text{, and}\\
    \Xnegi & \coloneqq \{\alpha \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\}.
  \end{align*}
  %
  By definition of \Xposi and \Xnegi, $\I_{i}$ is a model of
  $\smash{\bigwedge_{\alpha\in\Xposi}\alpha}$ and $\smash{\bigwedge_{\alpha\in\Xnegi}\lnot\alpha}$.
  %
  Now, let $\Xnegi=\{\alpha_{i,1}, \ldots, \alpha_{i,\ell_{i}}\}$. We have that
  $\I_{i}\models \lnot\alpha_{i,j}$ for $1 \leq j \leq \ell_{i}$. By Lemma
  \ref{lem:weakly-negation-inconsistent}, we get that there exists ${\I_{i}}'$ such that
  ${\I_{i}}'\models {\alpha_{i,j}}^{*}$. By induction, we get that ${\I_{i}}'\models\Omf_{X_{i}}$.

  If all $\Omf_{X_{i}}$ are consistent, there exist interpretations $\I_{i}$ such that
  $\I_{i}\models\Omf_{X_{i}}$. W.l.o.g., we can assume that the interpretations $\I_{i}$ share the same domain $\Delta$
  and that individual names are interpreted in the same way.  Then, $\I_{i}$ is a model of
  $\bigwedge_{\bsf(\oalpha)\in X_i}\alpha$,
  $\bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\alpha^{*}$ and \RO. Due to Lemma
  \ref{lem:weakly-negation-inconsistent}, $\I_{i}$ also models
  $\bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha$. Hence, $\Xmc$ is admissible.
\end{proof}

In the former case, i.e.\ $\OCR\cup\ORR\neq\emptyset$, we use the renaming technique
of~\cite{BaGL-KR08,BaGL-ToCL12} as in the proof of
Theorem~\ref{thm:shoiqshoq-with-rigid-names-twoexptime}. Due to the interaction of the rigid names,
we must reason over all $\Bmf_{X_{i}}$ simultaneously.

\begin{definition}[Renamed axiom, sets of positive and negative induced renamed o-axioms, induced
  object ontology]\label{def:renaming}
  Let $\Xmc = \{X_{1}, \ldots, X_{k}\}$ be a set of restricted types and let $\alpha$ be an axiom
  over \Osig.
  %
  For $\iota\in\nat$, the \emph{renamed axiom $\alpha^{(\iota)}$} is obtained from $\alpha$
  by replacing all flexible concept names $A$, i.e.\ $A \in \OC \setminus \OCR$, with a copy $A^{(\iota)}$
  and all flexible role names $r$ with a copy $r^{(\iota)}$ where we assume w.l.o.g.\ that $A^{(\iota)}$ and
  $r^{(\iota)}$ do not occur in \Bmf.
  
  Then, the \emph{set of positively induced renamed o-axioms \Xpos}, the \emph{set of negatively induced
    renamed o-axioms \Xneg}, the \emph{renamed object RBox $\RO'$} and the \emph{induced object
    ontology $\Omf_{\Xmc}=(\Omc_{\Xmc},\RO')$} are defined as follows:
  \begin{align*}
    \Xpos & \coloneqq \smash{\bigcup_{i=1}^{k}}\vphantom{\bigcup_{i}}\{\alpha^{(i)} \mid \bsf(\oax{\alpha})\in X_{i}\},\\
    \Xneg & \coloneqq \bigcup_{i=1}^{k}\{\alpha^{(i)} \mid \bsf(\oax{\alpha})\in\ran(\bsf)\setminus X_{i}\},\\
    \RO' & \coloneqq \bigcup_{i=1}^{k}\{\alpha^{(i)} \mid \alpha\in\RO\} \text{, and}\\
    \Omc_{\Xmc} & \coloneqq \bigwedge_{\beta\in\Xpos} \beta\ \land\ \bigwedge_{\beta\in\Xneg}
                  \beta^{*}.
  \end{align*}

  \vspace{-1.7\baselineskip}
\end{definition}

Although the next lemma also holds if no rigid names are present, we state it explicitly with rigid
names, as in the other case we will use Lemma~\ref{lem:admissibility-without-rigid}. From now on,
let $\alpha$ always denote an original axiom and $\beta$ an renamed axiom.

\begin{lemma}\label{lem:admissibiliy-with-rigid}
  If rigid names are present, i.e.\ $\OCR\cup\ORR\neq\emptyset$, the set \Xmc of restricted types is
  admissible iff the induced object ontology $\Omf_{\Xmc}$ is consistent.
\end{lemma}
\begin{proof}
  We can reuse the claim made in the proof of
  Theorem~\ref{thm:shoiqshoq-with-rigid-names-twoexptime}: \Xmc is admissible iff $\Bmf_{\Xmc}$ is
  consistent where $\Bmf_{\Xmc}$ is defined as
  \begin{align*}
    \Bmf_\Xmc \coloneqq \left(\bigwedge\nolimits_{1\leq\iota\leq k}\left(\bigwedge_{\bsf(\oalpha)\in X_{\iota}}\alpha^{(\iota)}\ \land
      \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_{\iota}}\lnot\alpha^{(\iota)}\right), \quad\RO'\right).
  \end{align*}
  %
  Hence, we only have to show that $\Bmf_{\Xmc}$ is consistent iff $\Omf_{\Xmc}$ is consistent. Let
  $\Xneg=\{\beta_{1}, \ldots, \beta_{\ell}\}$.

  If there exists an \Osig-interpretation \Gmc such that $\Gmc\models\Bmf_{\Xmc}$, then we also have
  that $\Gmc\models\lnot\beta_{i}$ for all $1 \leq i \leq \ell$. Due to
  Lemma~\ref{lem:weakly-negation-inconsistent} and by induction, there is some $\Gmc'$ such that
  $\Gmc'\models\beta_{i}^{*}$ for all $1 \leq i \leq \ell$. Hence, $\Gmc'$ is a model of $\Omf_{\Xmc}$.

  Conversely, if there exists an \Osig-interpretation \Gmc such that $\Gmc\models\Omf_{\Xmc}$, then we also have
  that $\Gmc\models\beta_{i}^{*}$ for all $1 \leq i \leq \ell$. By
  Lemma~\ref{lem:weakly-negation-inconsistent}, we know that $\Gmc\not\models\beta_{i}$. Hence,
  $\Gmc\models\lnot\beta_{i}$ and $\Gmc\models\Bmf_{\Xmc}$.
  


  % If $\Omc_{\Xmc}$ is consistent, then there exists an interpretation \II such that
  % $\I\models\Omc_{\Xmc}$. Let $\Xneg=\{\beta_{1}, \ldots, \beta_{l}\}$. We have that
  % $\I\models{\beta_{j}}^{*}$ for $1 \leq j \leq l$. By Lemma \ref{lem:weakly-negation-inconsistent}
  % we know that $\I\not\models\beta_{j}$ and, hence, $\I\models\lnot\beta_{j}$. By induction, we get
  % \begin{align*}
  %   \I \models & \left(\bigwedge_{\beta\in\Xpos} \beta\ \land\ \bigwedge_{\beta\in\Xneg} \lnot\beta,
  %   \quad\RO'  \right)
  % \end{align*}
  % We define \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1}), \ldots, \I_k=(\Delta,\cdot^{\I_k})$
  % as follows:
  % \begin{align*}
  %   \Delta & \coloneqq \Delta^{\I},\\
  %   A^{\I_{i}} & \coloneqq A^{\I} \qquad \text{for all $A\in\OCR$ occurring in \Xmc,}\\
  %   A^{\I_{i}} & \coloneqq (A^{(i)})^{\I} \qquad \text{for all $A\in\OC\setminus\OCR$ occurring in \Xmc,}\\
  %   r^{\I_{i}} & \coloneqq r^{\I} \qquad \text{for all $r\in\ORR$ occurring in \Xmc,}\\
  %   r^{\I_{i}} & \coloneqq (r^{(i)})^{\I} \qquad \text{for all $r\in\OR\setminus\ORR$ occurring in
  %                \Xmc, and}\\
  %   a^{\I_{i}} & \coloneqq a^{\I} \qquad \text{for all $a\in\OI$ occurring in \Xmc.}
  % \end{align*}
  % Condition (I) of Definition \ref{def:admissibility} is fulfilled since rigid names and individual
  % names are defined the same for all $\I_{i}$.
  % %
  % By the definition of $\I_{i}$, we have that $\I_{i}\models\alpha$ iff
  % $\I\models\alpha^{(i)}$. Hence, we know that $\I_{i}$ is a model of
  % $\bigwedge_{\bsf(\oax{\alpha})\in X_{i}}\alpha$,
  % $\bigwedge_{\bsf\oax{\alpha}\in\ran(\bsf)\setminus X_{i}}\lnot\alpha$ and \RO and \Xmc is
  % admissible.

  % If \Xmc is admissible, then there exist \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1})$,
  % \ldots, $\I_k=(\Delta,\cdot^{\I_k})$ such that $x^{\I_i}=x^{\I_j}$ for all
  % $x\in\OI\cup\OCR\cup\ORR$ and all $i,j\in\{1,\dots,k\}$, and every $\I_i$, $1\le i\le k$, is a
  % model of the \LO-BKB $\Bmf_{X_{i}}= (\B_{X_i},\RO)$ over~\Osig where
  % $\B_{X_i}:=\bigwedge_{\bsf(\oalpha)\in X_i}\alpha\ \land
  % \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha$. We define the
  % \Osig-interpretation \II as follows:
  % \begin{align*}
  %   \Delta^{\I} & \coloneqq \Delta,\\
  %   A^{\I} & \coloneqq A^{\I_{i}} \qquad \text{for $A\in\OCR$ and some $1\leq i \leq k$,}\\
  %   (A^{(i)})^{\I} & \coloneqq A^{\I_{i}} \qquad \text{for $A\in\OC\setminus\OCR$,}\\
  %   r^{\I} & \coloneqq r^{\I_{i}} \qquad \text{for $r\in\ORR$ and some $1\leq i \leq k$,}\\
  %   (r^{(i)})^{\I} & \coloneqq r^{\I_{i}} \qquad \text{for $r\in\OR\setminus\ORR$, and}\\
  %   a^{\I} & \coloneqq a^{\I_{i}} \qquad \text{for $a\in\OI$ and some $1\leq i \leq k$.}\\
  % \end{align*}
  % Again, by definition of \I, we have that $\I\models\alpha^{(i)}$ iff $\I_{i}\models\alpha$. Thus, we
  % get that \I is a model of $\bigwedge_{\beta\in\Xpos} \beta$,
  % $\bigwedge_{\beta\in\Xneg} \lnot\beta$ and $\RO'$. Due to Lemma
  % \ref{lem:weakly-negation-inconsistent}, \I is also models $\bigwedge_{\beta\in\Xneg}
  % \beta^{*}$. Hence, $\Omc_{\Xmc}$ is consistent.
\end{proof}

To sum up, we can decide admissibility of~\Xmc by checking, respectively,~$\Omf_{\Xmc}$
or~$\Omf_{X_{i}}$ for consistency, depending on whether rigid names are present or not. 


\subsection{Outer consistency}
\label{sec:outer-consistency-to-standard-reasoning}

In the decision procedures described in Section~\ref{sec:complexity-consis-problem}, we always
construct the set \Xmc first, and then check whether \Bmfb is outer consistent w.r.t.~\Xmc. In the
general case with rigid names we enumerate all sets $\Xmc\subseteq\powerset{\ran(\bsf)}$. When only
rigid concept names and no rigid role names are present, we non-deterministically guess a set \Xmc.
For the case without rigid names we construct the largest possible set \Xmc that is admissible,
and argue that any \Bmfb that is outer consistent w.r.t.\ some admissible $\Xmc'$ is also outer
consistent w.r.t.~\Xmc. Hence, we only have to test outer consistency w.r.t.\ to \Xmc. But all these
techniques involve the possibly unnecessary, exponentially large construction of \Xmc.
%
Alternatively, we can also use the following lemma, which is a direct consequence of
Lemma~\ref{lem:admissible-and-outerConsistent}.

\begin{lemma}
  \label{lem:consistant-and-admissible-types}
  The \LMLO-BKB \Bmf is consistent iff there is an \Msig-interpretation \Hmc such that
  $\Hmc \models \Bmfb$ and $\Zmc_{\Hmc} = \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}$
  is admissible.
\end{lemma}

\begin{proof}
  Let us assume that \Bmf is consistent.
  By Lemma~\ref{lem:admissible-and-outerConsistent}, we know that if \Bmf is consistent, then there exists
  an admissible set \Xmc such that \Bmfb is outer consistent w.r.t~\Xmc. By the definition of outer
  consistency, there exists an \Msig-interpretation \Hmc that models \Bmfb and weakly respects
  $(\ran(\bsf), \Xmc)$.  By definition, we have that $\Zmc_{\Hmc} \subseteq \Xmc$. Since every subset of an
  admissible set is also admissible, \Zmc is also admissible.

  For the `if' direction we assume that $\Hmc \models \Bmfb$ and that~\Zmc is admissible.
  If $\Hmc \models \Bmfb$, then~\Bmfb is outer consistent w.r.t~\Zmc. Since~\Zmc is admissible, we
  know, due to Lemma~\ref{lem:admissible-and-outerConsistent}, that \Bmf is consistent.
\end{proof}



Due to Lemma \ref{lem:consistant-and-admissible-types}, we do not need to construct the set \Xmc
first. We can also enumerate all models \Hmc of \Bmfb, and check for each \Hmc if the occurring
types are admissible. If there exist one model of \Bmfb, then there exists infinitely
many. But we only need to check those that are \emph{essentially different}, i.e.~those for which the set of
occurring restricted types differs.

\begin{definition}[Essentially equal interpretations]
  For an \Msig-interpretation \Hmc, the \emph{set of occurring, restricted types $\Zmc_{\Hmc}$} is defined as
  \begin{align*}
    \Zmc_{\Hmc} & \coloneqq \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}.
  \end{align*}
  The two \Msig-interpretations $\Hmc_{1}$ and $\Hmc_{2}$ are \emph{essentially equal} if $\Zmc_{\Hmc_{1}} =
  \Zmc_{\Hmc_{2}}$.
\end{definition}

Using the results of Lemma \ref{lem:admissibility-without-rigid}, \ref{lem:admissibiliy-with-rigid}
and \ref{lem:consistant-and-admissible-types}, we can construct a simple algorithm, as depicted in
Algorithm~\ref{alg:1}. Here, $\Omc_{Z_{i}}$ and $\Omc_{\Zmc_{\Hmc}}$ are respectively defined as in
Lemma~\ref{lem:admissibility-without-rigid} and Definition~\ref{def:renaming}. We enumerate all
essentially equal models of \Bmfb and check for each model \Hmc whether $\Zmc_{\Hmc}$ is
admissible. Note that on the object level, only classical consistency checks are used. On the meta level,
the bare information about consistency is not sufficient, since we also need information about the
restricted types occurring in the model. Hence, we need a DL reasoner that constructs a model and,
if consistent, returns the set of occurring restricted types.


\IncMargin{1em}
\RestyleAlgo{ruled}
\begin{algorithm}[t]
  \SetAlgoVlined
  \setstretch{1.1}
  \DontPrintSemicolon
  \SetKwData{true}{true}
  \SetKwData{false}{false}
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  %
  \Input{\LMLO-BKB \Bmf}
  \Output{\true if \Bmf is consistent, \false otherwise}
  \BlankLine
  $\Hmf \coloneqq \{\Hmc \mid \Hmc\models\Bmfb \text{, up to essential equality}\}$\;
  \For{$\Hmc \in \Hmf$}{
    $\Zmc_{\Hmc} \coloneqq \{\mathsf{type}_{\ran(b)}^{\Hmc}(d) \mid d \in \Delta^{\Hmc}\}$\;
    \eIf{\Bmf contains rigid names}{
      \If{($\Omc_{\Zmc_{\Hmc}}, \RO')$ is consistent}{
        \vspace{0.5ex}\Return{\true}
      }
    }{
      $\Zmc_{\Hmc} = \{Z_{1}, \dots, Z_{k}\}$\;
      \If{$(\Omc_{Z_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$}{
        \vspace{0.5ex}\Return{\true}
      }
    }
  }
  \Return{false}
  \caption{Algorithm for checking consistency of \LMLO-BKB \Bmf}\label{alg:1}
\end{algorithm}

\begin{lemma}\label{lem:alg1-sound-complete-terminating}
  Algorithm~\ref{alg:1} is sound, complete, and terminating.
\end{lemma}
\begin{proof}
  Up to essential equivalence, there are only finitely many models. Checking whether \Hmc is a model and checking whether
  $\Omf_{\Zmc_{\Hmc}}$ or $\Omf_{Z_{i}}$ is consistent, is decidable. Thus, Algorithm~\ref{alg:1}
  terminates.

  Let us assume that \Bmf is consistent. By Lemma~\ref{lem:consistant-and-admissible-types}, there
  exists a model~\Hmc of~\Bmfb such that~$\Zmc_{\Hmc}$ is admissible. W.l.o.g., we can assume that
  $\Hmc\in\Hmf$. 
  %
  % Then, there exists a model \J of \Bmf and, hence, there is a model $\Hmc\in\Hmf$ of \Bmfb such
  % that \Hmc and \Jb are essential equal. By Lemma~\ref{lem:consistant-and-admissible-types},
  % $\Zmc_{\Hmc}$ is admissible.
  % 
  Depending on whether rigid names are present, due to
  Lemma~\ref{lem:admissibility-without-rigid} and Lemma~\ref{lem:admissibiliy-with-rigid} Algorithm~\ref{alg:1} will successfully check that
  $\Omf_{Z_{i}}$, for all $1\leq i \leq k$, or $\Omf_{\Zmc_{\Hmc}}$ is consistent. Hence, it
  returns \true.

  Let us assume that the algorithm returns \true. Then, there is some $\Hmc\in\Hmf$ such that~$\Omf_{Z_{i}}$,
  for all $1\leq i \leq k$, or~$\Omf_{\Zmc_{\Hmc}}$ is consistent. By
  Lemma~\ref{lem:admissibility-without-rigid} and Lemma~\ref{lem:admissibiliy-with-rigid}, we know
  that $\Zmc_{\Hmc}$ is admissible. Lemma~\ref{lem:consistant-and-admissible-types} yields that \Bmf
  is consistent.
\end{proof}

In Algorithm~\ref{alg:1}, we need to enumerate all models of \Bmfb up to essential
equivalence. Therefore, we need an algorithm deciding not only the consistency of a DL ontology but also
outputs information about a model. We discuss further issues about the core algorithm and core
reasoner which we use in the next section.


\section{Contextual Hypertableau}
\label{sec:using-hypertableau}

We have to take several arguments into account in order to evaluate, which reasoner or decision
procedure we use as core reasoner to decide the two subtasks.
%
First of all as mentioned earlier, in addition to checking consistency on meta level, we also need
the set of occurring restricted types of a model. Hence, an reasoner that constructs a model is
necessary for enumerating the models of \Bmfb. As pointed out in~\cite{MaLHSP-ORE15}, there exist
three major approaches used in OWL reasoners: consequence-, model construction- and
rewriting-based. \emph{Consequence-based} approaches are classically employed for the entailment
problem in lightweight DLs such as \EL, while \emph{rewriting} approaches are usually used for
specific reasoning tasks, such as for query answering. \emph{Model construction-based} approaches
are utilised for expressive DLs, i.e.\ any extension of \ALC, and try to build a model based on the
knowledge base to check consistency. These include tableau and hypertableau techniques. Since we
also need the information about the restricted types of a model, we are looking for a model
construction-based reasoner.

Furthermore, by means of maintenance, we will use the same reasoner for the meta level and the
object level.
%
Since a dominant framework supporting OWL, the OWL API~\cite{HoB-SW11}, is implemented in Java, so is the
majority of the available reasoners. Therefore, we also use Java for our OWL-conformant reasoner and
implement the \textsf{OWLReasoner} interface of the OWL~API.

Last but not least, the performance of the reasoner in consistency checking is important for
us. Therefore, we take a look at the OWL Reasoner Evaluation Competition
Report~\cite{PaMGGS-SSWS15}, especially at the results of the discipline: \emph{OWL DL
  Consistency}. This discipline, among others, was won by Konclude~\cite{StLG-JWS14}, a
 hybrid reasoner that combines tableau calculus with a variant of a consequence-based
saturation procedure. However, due to this hybrid approach it is unsuitable in our
setting. Besides that, it is implemented in C++ and we focus on Java-based reasoners. The
next candidate is HermiT~\cite{GHM-JAR14}, a Java-implemented reasoner based on the hypertableau
calculus~\cite{MoSH-JAIR09}. Since it meets all our requirements, we use HermiT as core reasoner in
our implementation.

% \todo[inline]{hypertableau avoid unnecessary nondeterminism (or-branching)}

% \todo[inline]{Hermit computes premodels which can be extended to model of ontology. blocked individuals, same
% concept labels -> premodel has the same restricted type}

% \todo[inline]{different blocking strategies dependant on used dl. anywhere blocking, ancestor blocking, atomic
% single blocking, full single blocking, }

% \todo[inline]{full subset blocking could be problematic, but is not used in HermiT.}

Before we discuss the details of a refinement of our algorithm with regard towards an implementation, we
present the relevant parts of the hypertableau algorithm and refer the interested reader
to~\cite{MoSH-CADE07,MoSH-DL07,MoSH-JAIR09}. Like other tableau-based methods, the hypertableau
calculus tries to construct an abstraction of a model for a given ontology to check whether that
ontology is consistent. But in contrast to other tableau calculi, it operates on a set of
\emph{DL-clauses} and an ABox, instead of a TBox and an ABox.

\begin{definition}[DL-Clause~\cite{MoSH-JAIR09}]
  The concepts $\top$, $\bot$, and concepts of the form $A$ and $\lnot A$ for $A\in\MC$ are called
  \emph{literal concepts}. Let \MV be the set of variables disjoint from the set of individuals
  \MI. An \emph{atom} is an expression of the form $B(x)$, $(\atleast{n}{s}{B})(x)$, $r(x,y)$, or
  $x\approx y$, for $x,y\in\MV\cup\MI$, $B$ a literal concept, $r$ an atomic role, $s$ a role, and
  $n$ a positive integer. A \emph{DL-clause} is an expression of the form
  \begin{align*}
    U_{1} \land\dots\land U_{m} \to V_{1} \lor\dots\lor V_{n}
  \end{align*}
  where $U_{i}$ and $V_{j}$ are atoms, $m,n\geq0$. The conjunction $U_{1} \land\dots\land U_{m}$ is
  called the \emph{antecedent}, and the disjunction $V_{1} \lor\dots\lor V_{n}$ is called
  \emph{consequent}. The empty antecedent and the empty consequent are respectively written as $\top$
  and $\bot$.

  Let \HH be an \Msig-interpretation and let $\mu:\MV\to\Delta^{\Hmc}$ be a mapping from variables to
  domain elements. We define $\cdot^{\Hmc,\mu}$ as follows:
  \begin{align*}
    c^{\Hmc,\mu} & \coloneqq
      \begin{cases}
        c^{\Hmc} & \text{ if $c\in\MI$, and}\\
        \mu(c)  & \text{ if $c\in\MV$}.
      \end{cases}
  \end{align*}
  Satisfaction of an atom, DL-clause, and a set of DL-clauses \Cmc in \Hmc and $\mu$ is defined in
  Table~\ref{tab:satisfaction-clauses}. 
\end{definition} 
\begin{table}
  \caption{Satisfaction of DL-Clauses}
  \centering
  {\renewcommand{\arraystretch}{1.1}
  \begin{tabularx}{0.9\linewidth}{l@{\hskip 10pt iff\hskip 10pt}L}
    \toprule
    $\Hmc,\mu\models C(c)$ & $c^{\Hmc,\mu} \in C^{\Hmc}$\\
    $\Hmc,\mu\models r(c,d)$ & $(c^{\Hmc,\mu},d^{\Hmc,\mu}) \in r^{\Hmc}$ \\
    $\Hmc,\mu\models c\approx d$ &  $c^{\Hmc,\mu}=d^{\Hmc,\mu}$ \\
    $\Hmc,\mu\models\bigwedge_{i=1}^{m}U_{i}\to\bigvee_{j=1}^{n}V_{j}$ 
        & $\Hmc,\mu\models U_{i}$ for each $1\leq i\leq m$ implies \hspace{2cm} \hspace*{1cm}$\Hmc,\mu\models V_{j}$ for some
          $1\leq j\leq n$\\
    $\phantom{\Hmc,\mu}\mathllap{\Hmc}\models\bigwedge_{i=1}^{m}U_{i}\to\bigvee_{j=1}^{n}V_{j}$
        & $\Hmc,\mu\models\bigwedge_{i=1}^{m}U_{i}\to\bigvee_{j=1}^{n}V_{j}$ for all mappings
          $\mu$\\
    $\phantom{\Hmc,\mu}\mathllap{\Hmc}\models\Cmc$ 
        & $\phantom{\Hmc,\mu}\mathllap{\Hmc}\models\mathbf{r}$ for all $\mathbf{r}\in\Cmc$\\ \bottomrule
  \end{tabularx}}
  \label{tab:satisfaction-clauses}
\end{table}

In the hypertableau algorithm, a few preprocessing steps are necessary, namely \emph{elimination of
  transitivity axioms}, \emph{normalisation} and \emph{clausification}. The clausification
translates a normalised DL ontology $\Omf = (\Omc, \Rmc)$ without transitivity axioms into a pair
\CA, where \Cmc is a set of DL-clauses and \A is an ABox, and \Omf and \CA are equisatisfiable.
Here, we omit further details of the preprocessing steps, but emphasise that the preprocessing not
only preserves satisfiability, but also satisfiability w.r.t.~essential equality.  Let \Kmc be the
input ontology and \CA the clausification after normalisation. There exists a model \I of \Kmc iff
the exists a model \Hmc of \CA such that \I and \Hmc are essentially equal. Hence, it is sufficient
to consider the clausification of the outer abstraction of an \LMLO ontology.

As typical for tableau algorithms, the hypertableau calculus uses a blocking strategy to ensure
termination. Intuitively, in the construction of a model, a blocked individual is replaced by its
blocker. Thus, by the unravelling technique infinite models can be constructed. Here, it is important for us, that
the blocked individual and its blocker have the same restricted type. This holds for all blocking
strategies used in the hypertableau algorithm. For the sake of conciseness, we omit the specific
blocking strategy in our definition of the hypertableau algorithm and refer to~\cite{MoSH-JAIR09}
for a complete definition.

\begin{table}
  \caption{Derivation rules of the hypertableau calculus~\cite{MoSH-JAIR09}}
  \label{tab:derivation-rules}
  \centering
  \begin{tabularx}{0.9\linewidth}{ll@{ }L}
    \toprule
    & If &  \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep,leftmargin=\widthof{3.}+\labelsep,topsep=0pt]
           \item $\mathbf{r} \in \Cmc$, where $\mathbf{r} = U_{1} \land\dots\land U_{m} \to V_{1}
             \lor\dots\lor V_{n}$, and
           \item a mapping $\sigma$ from the variables in $\mathbf{r}$ to the individuals of~\A
             exists such that 
             \begin{enumerate}[nosep,label*=\arabic*.,topsep=0pt]
             \item there is no $x\in\NV$ s.t.\ $\sigma(x)$ is indirectly blocked,
             \item $\sigma(U_{i})\in\A$ for each $1\leq i \leq m$, and
             \item $\sigma(V_{j})\notin\A$ for each $1\leq j \leq n$
             \end{enumerate}%
           \end{enumerate} \\ 
    \multirow{-3}{*}[7ex]{\textit{Hyp}-rule} & then &
        $\A_{1} \coloneqq \A \cup \{\bot\}$ if $n=0$; \\
    & & $\A_{j} \coloneqq \A \cup \{\sigma(V_{j})\}$ for $1 \leq j \leq n$ otherwise.
      \\ \midrule
    & If & \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep,leftmargin=\widthof{3.}+\labelsep,topsep=0pt]
           \item $(\atleast{n}{r}{B})(c)\in\A$,
           \item $c$ is not blocked in \A, and
           \item \A does not contain individuals $u_{1},\dots,u_{n}$ such that
             \begin{enumerate}[nosep,label*=\arabic*.,topsep=0pt]
             \item $\{r(c,u_{i}), B(u_{i})\mid 1 \leq i \leq n\}\cup\{u_{i}\not\approx u_{j}\mid
               1\leq i < j\leq\}\in\A$, and
             \item for each $1\leq i \leq n$, neither $u_{i}$ is a successor of $c$ or $u_{i}$ is
               not blocked in \A,
             \end{enumerate}
           \end{enumerate}\\
    \multirow{-2}{*}[8ex]{$\geq$-rule} & then & $\A_{1}\coloneqq\A\cup\{r(c,t_{i}), B(t_{i}) \mid 1\leq i
                                           \leq n\}\cup\{t_{i}\not\approx t_{j} \mid 1\leq i < j\leq
                                           \}$ where $t_{1},\dots,t_{n}$ are fresh, distinct
                                           successors of $c$. \\ \midrule
    & If & \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep,leftmargin=\widthof{3.}+\labelsep,topsep=0pt]
           \item $c\approx d\in\A$,
           \item $c\neq d$, and
           \item neither $c$ nor $d$ is indirectly blocked
           \end{enumerate}\\
    \multirow{-2}{*}{$\approx$-rule} & then & 
       $\A_{1}\coloneqq \mergeABox{\A}{c\to d}$ if $d$ is a named individual, or $d$ is a root
                                              individual and $c$ is not a named individual, or $c$
                                              is a descendant of $d$; \hspace{10cm}
                                              $\A_{1}\coloneqq\mergeABox{\A}{d\to c}$ otherwise.\\ \midrule
    & If & $c\not\approx c\in\A$ or $\{A(c), \lnot A(c)\}\subseteq\A$ where $c$ is not directly blocked \\
    \multirow{-2}{*}{$\bot$-rule} & then & $\A_{1}\coloneqq\A\cup\{\bot\}$ \\ \midrule
    & If & \vspace*{-0.88\topsep}
           \begin{enumerate}[nosep,leftmargin=\widthof{3.}+\labelsep,topsep=0pt]
           \item $c\approx d@_{\atmost{n}{r}{B}}^{u}\in\A$,
           \item $u$ is a root individual,
           \item $c$ is a blockable individual that is not a successor of $u$,
           \item $d$ is a blockable individual, and
           \item neither $c$ nor $d$ is indirectly blocked
           \end{enumerate} \\
    \multirow{-2}{*}[6ex]{\textit{NI}-rule} & then & $\A_{i}\coloneqq\mergeABox{\A}{s\to \|u.\langle
                                                r,B,i \rangle \|_{\A}}$ for each $1\leq i
                                                \leq n$. \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{definition}[Hypertableau Algorithm~\cite{MoSH-JAIR09}]
  Given a set of named individual \MI, the set of \emph{root individuals \MO} is the smallest set
  such that $\MI\subseteq\MO$, and if $x\in\MO$, then $x.\langle r,B,i \rangle\in\MO$ for each role
  $r$, literal concept $B$ and positive integer $i$. The set of \emph{all individuals} \MA is the
  smallest set such that $\MO\subseteq\MA$, and if $x\in\MA$, then $x.i\in\MA$ for each positive
  integer~$i$. $x.i$ is a \emph{successor} of $x$, and \emph{descendant} is the transitive closure
  of successor.

  In the hypertableau algorithm, an ABox can additionally contain
  \begin{itemize}
  \item annotatd equalities,
  \item $\bot$, which is equivalent to the concept assertion $\bot(a)$ for some $a\in\MI$,
  \item assertions that contain individuals from \MA and not only \MI, and
  \item renamings of the form $a\mapsto b$.
  \end{itemize}
  The ABox \emph{\prune{\A}{c}} is obtained from \A by removing all assertions containing
  descendants of~$c$.  The ABox \emph{\mergeABox{\A}{s\to t}} is obtained from \prune{\A}{s} by
  replacing all individuals $s$ with individual $t$ in all assertions and annotation, and, if both
  $s$ and $t$ are root individuals, adding the renaming $s\mapsto t$.

  Table~\ref{tab:derivation-rules} specifies \emph{derivation rules} that, given an ABox \A and a
  set of DL-Clauses \Cmc, derive one or more ABoxes $\A_{1},\dots,\A_{n}$.

  An ABox \A contains a \emph{clash} iff $\bot\in\A$. Otherwise, \A is \emph{clash-free}. 
  
  For a set of DL-clauses \Cmc and an input ABox \A, a \emph{derivation} is a pair $(T,\lambda)$
  where $T$ is a finitely branching tree and $\lambda$ is a function that labels the nodes of $T$
  with ABoxes such that for each node $t\in T$:
  \begin{itemize}
  \item $\lambda(t)=\A$ if $t$ is the root of $T$,
  \item $t$ is a leaf of $T$ if $\bot\in\lambda(t)$ or no derivation rule is applicable to
    $\lambda(t)$ and \Cmc, and
  \item $t$ has children $t_{1},\dots,t_{n}$ such that $\lambda(t_{1}),\dots,\lambda(t_{n})$ are
    exactly the results of applying one applicable rule to $\lambda(t)$ and \Cmc in all other
    cases.
  \end{itemize}
  An ABox is \emph{complete} iff it labels some leaf of $T$.
\end{definition}

Note that the annotation $\ldots @_{\atmost{n}{r}{B}}^{u}$ used in the \textit{NI}-rule does not
effect the meaning of the equality, it only records its provenance. They are introduced in the
clausification, but since the details are not important here, we omit them and refer
to~\cite{MSH-DL08}.

Through the rest of this section let \CA be the clausification of the outer abstraction
$\Omf^{\bsf}$. Hence, \A is an \LM-ABox over \Msig.
%
In Algorithm~\ref{alg:1}, we need to enumerate all models for \Bmfb up to essential equality. The
main idea is that it is sufficient to look at the complete, clash-free ABoxes, since every model of
the ontology has such a corresponding ABox.

\begin{lemma}\label{lem:model-has-abox}
  In any derivation for \CA and for each model \Hmc of \CA, there exists some leaf node labelled with
  a clash-free ABox $\A'$ such that $\Hmc'\models\A'$, where \Hmc and $\Hmc'$ are essentially equal.
\end{lemma}
\begin{proof}
  We prove the lemma by induction on the derivation rule application. Let \Cmc be a set of
  DL-clauses, let \A be an ABox and let $\Hmc\models\CA$.
  
  \noindent
  \begin{tabularx}{1.0\linewidth}{@{}lX@{}}
    \textit{Hyp}-rule: 
    & Assume that the \textit{Hyp}-rule is applicable for
      $\mathbf{r} = U_{1} \land\dots\land U_{m} \to V_{1} \lor\dots\lor V_{n}\in\Cmc$. Then there is a
      mapping $\sigma$ from the variables in $\mathbf{r}$ to the individuals in \A such that
      $\sigma(U_{i})\in\A$ and $\sigma(V_{j})\notin\A$, for each $1\leq i \leq m$, $1\leq j \leq
      n$. Since $\Hmc\models\mathbf{r}$, there exists mapping $\mu$ from the variables in $\mathbf{r}$
      to elements of $\Delta^{\Hmc}$ such that $\mu(x) = \sigma(x)^{\Hmc}$ and $\Hmc,\mu\models V_{j}$
      for some $1\leq j \leq n$. Thus, $\Hmc\models\sigma(V_{j})$ and, hence, $\Hmc\models\A_{j}$ for
      some $1\leq j \leq n$.\\
    $\geq$-rule:
    & If the $\geq$-rule is applicable, we have that $\atleast{n}{r}{B}(s)\in\A$. Since $\Hmc\models\A$,
      there exist $d_{1}, \dots, d_{n} \in B^{\Hmc}$ with $(s^{\Hmc},d_{i})\in r^{\Hmc}$. We define $\Hmc'$
      like \Hmc, but additionally set $t_{i}^{\Hmc'} = d_{i}$, where $t_{i}$ is the fresh successor of
      $c$ introduced by the $\geq$-rule. Hence, $\Hmc'$ models $\A_{1}$ and is essentially equal to
      \Hmc.\\
    $\approx$-rule
    & If the $\approx$-rule is applicable, we have that $\Hmc\models s\approx t \in \A$ and, hence,
      $s^{\Hmc}=t^{\Hmc}$. Thus, $\Hmc$ also models $\Amc_{1}\coloneqq\mathsf{merge}_{\A}(s \to t)$ or
      $\Amc_{1}\coloneqq\mathsf{merge}_{\A}(t \to s)$. \\
    $\bot$-rule:
    & Since \A has a model, the $\bot$-rule is not applicable.\\
    \textit{NI}-rule
    & analogous to the $\approx$-rule.
  \end{tabularx}
\end{proof}

Similar as for a set of restricted types \Xmc for which we defined admissibility (see
Definition~\ref{def:admissibility}) to assure that the corresponding o-axioms `fit together', we
define admissibility of an ABox.

\begin{definition}[Admissibility of an ABox]\label{def:admissibility-of-abox}
  Let \A be an \LM-ABox over \Msig and let \RO be an object RBox. W.l.o.g., we assume that the meta individuals
  occurring in \A are $c_{1}$, \dots, $c_{k}$. We call \A \emph{admissible} if there exist
  \Osig-interpretations $\I_{1} = (\Delta, \cdot^{\I_{1}})$, \dots,
  $\I_{k} = (\Delta, \cdot^{\I_{k}})$ such that
  \begin{itemize}
  \item $x^{\I_{i}} = x^{\I_{j}}$ for all $x \in \OCR \cup \ORR \cup \OI$ and all
    $i,j\in\{1,\dots,k\}$, and
  \item every $\I_{i}$, $1 \leq i \leq k$, is a model of the \LO-ontology $\Omf_{c_{i}} = (\Omc_{c_{i}},
    \RO)$ over \Osig where
    \begin{align*}
      \Omc_{c_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in\Zpos{c_{i}}} \alpha \land
                     \bigwedge_{\bsf(\oalpha)\in\Zneg{c_{i}}} \alpha^{*} \\
      \intertext{with}
      \Zpos{c} & \coloneqq \{A\in\ran(\bsf) \mid   A(c)\in\A\} \text{ and} \\
      \Zneg{c} & \coloneqq \{A\in\ran(\bsf) \mid \lnot A(c)\in\A\}. \qedhere
    \end{align*}
  \end{itemize}
\end{definition}

Obviously, if \A is not admissible, no model \Hmc of \A will have an admissible set of occurring
restricted types $\Zmc_{\Hmc}$. If, for example,
$\{A_{\oax{B(a)}}(s), A_{\oax{B\sqsubseteq\bot}}(s)\}\subseteq\A$, then for any model \Hmc the
restricted type of $s^{\Hmc}$ will contain $A_{\oax{B(a)}}$ and
$A_{\oax{B\sqsubseteq\bot}}$. Hence, $\Zmc_{\Hmc}$ is not admissible.

\begin{lemma}\label{lem:A-admissible-iff-ZH-admissible}
  Let \Ap be a \LM-ABox over \Msig such that \Ap is complete and clash-free. Then,
  \Ap is admissible if and only if there exists a model \Hmc of \Ap such that $\Zmc_{\Hmc}$ is
  admissible.
\end{lemma}

\begin{proof}
  In the completeness proof for the Hypertableau Algorithm (see \cite{MoSH-JAIR09}, Lemma 6) a model
  $\Hmc_{\CA}$ for \CA is constructed by an unravelling based on \Ap. Here, the domain elements are paths. We
  can extend this interpretation to $\Hmc_{\Ap}$ by additionally interpreting blockable individuals as follows:
  if $s$ is not blocked, then $s^{\Hmc_{\Ap}}\coloneqq \left[p\mid\frac{s}{s}\right]$ and if $s$ is
  blocked by $t$, then $s^{\Hmc_{\Ap}}\coloneqq \left[p\mid\frac{t}{s}\right]$ where $p$ is a path where
  $s$ does not occur. Hence, $\Hmc_{\Ap}$ is also a model of \Ap.

  W.l.o.g., we assume that the meta individuals occurring in \Ap are $c_{1}$, \dots, $c_{k}$.  For
  any interpretation \Hmc such that $\Hmc\models\Ap$, let
  $\Zmc_{\Hmc}=(Z_{1},\dots,Z_{k},Z_{k+1},\dots,Z_{\ell})$ such that
  $Z_{i}=\mathsf{type}_{\ran(b)}^{\Hmc}(c_{i}^{\Hmc})$ for $1\leq i\leq k$. Considering the
  conjunction of axioms as a set of conjuncts, we have that $\Omc_{c_{i}}\subseteq \Omc_{Z_{i}}$ where
  $\Omc_{c_{i}}$ (see Def.~\ref{def:admissibility-of-abox}) and $\Omc_{Z_{i}}$ (see
  Lem.~\ref{lem:admissibility-without-rigid}) are defined as
  \begin{align*}
    \Omc_{c_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in\Zpos{c_{i}}} \alpha \land
                     \bigwedge_{\bsf(\oalpha)\in\Zneg{c_{i}}} \alpha^{*}, \\
    \Omc_{Z_{i}} & \coloneqq \bigwedge_{\bsf(\oalpha)\in Z_i}\alpha\ \land
      \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus Z_i}\lnot\alpha.
  \end{align*}
  %
  If \Ap is not admissible, then $(Z_{1},\dots,Z_{k})$ cannot be admissible either. Hence, $\Zmc_{\Hmc}$ is
  also not admissible.

  If \Ap is admissible, then by definition there exist \Osig-interpretations $\I_{1},\dots,\I_{k}$
  modelling $\Omc_{c_{1}},\dots,\Omc_{c_{k}}$. First, we define
  $\Zneu{c_{i}} \coloneqq \ran(\bsf) \setminus (\Zpos{c_{i}}\cup\Zneg{c_{i}})$ as the set of
  abstracted concept names which do not occur neither as a positive nor negative concept assertion
  with $c_{i}$ in \Ap. Note that $\I_{i}$ always either models $\alpha$ or $\lnot\alpha$ for any
  o-axiom $\alpha$, and that by the construction of $\Hmc_{\Ap}$, $\Hmc_{\Ap}\models A(c)$ iff
  $A(c)\in\Ap$ for any $A\in\MC$. We define $\Hmc^{*}$ to be equal with $\Hmc_{\Ap}$ except that for
  all $\bsf(\oalpha)\in\ran(\bsf)$, we define $\bsf(\oalpha)^{\Hmc^{*}}$ as
  \begin{align*}
  \bsf(\oalpha)^{\Hmc^{*}}\coloneqq \bsf(\oalpha)^{\Hmc_{\Ap}} \cup \{c_{i}^{\Hmc_{\Ap}} \mid
  \bsf(\oalpha)\in\Zneu{c_{i}} \text { and }\I_{i}\models\alpha \}.
  \end{align*}
  Hence, with $Z_{i} = \mathsf{type}_{\ran(b)}^{\Hmc^{*}}(c_{i})$ we have that
  $\I\models\Omc_{Z_{i}}$. Since $\Zmc_{\Hmc^{*}} = (Z_{1},\dots,Z_{k})$, $\Zmc_{\Hmc^{*}}$ is
  admissible.
  %
  % \vspace{2cm}
  % If \Ap is admissible, then by definition there exist \Osig-interpretations $\I_{1},\dots,\I_{k}$
  % modelling $\Omc_{c_{1}},\dots,\Omc_{c_{k}}$. For any abstracted concept name $A_{\oalpha}$ which
  % does not occur neither as a positive nor negative concept assertion in \Ap, i.e.\  for any
  % $\bsf(\oalpha) \in \ran(\bsf) \setminus (\Zpos{c_{i}}\cup\Zneg{c_{i}})$, we have that either
  % $\I_{i}\models\Omc_{c_{i}}\land\alpha$ or $\I_{i}\models\Omc_{c_{i}}\land\lnot\alpha$.
  %
  % Furthermore, by construction of $\Hmc_{\Ap}$ we know that $\Hmc_{\Ap}\models A(c)$ iff
  % $A(c)\in\Ap$ for any concept assertion $A(c)$ with $A\in\MC$.
  %
  %
  % If \Ap is admissible, let $\I_{1},\dots,\I_{k}$ be the \Osig-interpretations modelling
  % $\Omc_{c_{1}},\dots,\Omc_{c_{k}}$. For any
  % $\bsf(\oalpha) \in \ran(\bsf) \setminus (\Zpos{c_{i}}\cup\Zneg{c_{i}})$, we have that $\I_{i}$ is
  % either a model of $\Omc_{c_{i}}\land\alpha$ or $\Omc_{c_{i}}\land\lnot\alpha$.  For any concept
  % assertion $A(c)$ with $A\in\MC$, $\Hmc_{\Ap}\models A(c)$ iff $A(c)\in\Ap$ by construction of
  % $\Hmc_{\Ap}$. However, if both $A(c)\notin\Ap$ and $\lnot A(c)\notin\Ap$, then $\Hmc_{\Ap}'$ which
  % is equal to $\Hmc_{\Ap}$ except that
  % $A^{\Hmc_{\Ap}'} \coloneqq A^{\Hmc_{\Ap}} \cup \{c^{\Hmc_{\Ap}}\}$ also models \Ap and
  % $A(c)$. Note here, that $\Hmc_{\Ap}'$ also models \A, but not necessarily \Cmc anymore.
  % % 
  % We define $\Hmc^{*}$ such that for all $\bsf(\oalpha) \in \ran(\bsf) \setminus
  % (\Zpos{c_{i}}\cup\Zneg{c_{i}})$ with $\I_{i}\models\Omc_{c_{i}}\land\alpha$ we set
  % $\bsf(\oalpha)^{\Hmc^{*}} \coloneqq \bsf(\oalpha)^{\Hmc_{\Ap}} \cup \{c_{i}^{\Hmc_{\Ap}}\}$. Thus,
  % $\I_{i}\models\Omc_{Z_{i}}$ where $Z_{i} = \mathsf{type}_{\ran(b)}^{\Hmc^{*}}(c_{i})$. Since
  % $\Zmc_{\Hmc^{*}} = (Z_{1},\dots,Z_{k})$, $\Zmc_{\Hmc^{*}}$ is admissible.
  %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % 
  % For any DL BKB \Bmf and DL axiom $\alpha$ it holds that if \Bmf is consistent then
  % either $\Bmf\land\alpha$ or $\Bmf\land\lnot\alpha$ is also consistent.
  % 
  % Let \Ap be admissible and $c_{1}$, \dots, $c_{k}$ the meta individuals occurring in \A. We define
  % $\HH$ such that
  % \begin{align*}
  %   \Delta^{\Hmc} & = \{c_{1}, \dots, c_{k}\}, \\
  %   c_{i}^{\Hmc} & = c_{i} \text{ for each individual $c_{i}$ that occurs in an assertion in \Ap}, \\
  %   A^{\Hmc} & = \{c_{i} \in \Delta^{\Hmc} \mid A(c_{i}) \in \Ap\} \text{ for all $A\in\MC$, and} \\
  %   r^{\Hmc} & = \{(c_{i}, c_{j}) \in \Delta^{\Hmc} \times \Delta^{\Hmc} \mid r(c_{i}, c_{j}) \in
  %   \Ap\} \text{ for all $r \in \MR$}.
  % \end{align*}
  % Clearly, \Hmc models all role assertions and all concept assertions of the form $A(c)$ with
  % $A\in\MC$ that occur in \Ap. For concept assertions of the form $\lnot A(c)$, we know that
  % $A(c)\notin\Ap$, since \Ap is clash-free and thus the $\bot$-rule was never applied. Therefore, we
  % have that $\Hmc\models\lnot A(c)$. For any assertion of the form $(\atleast{n}{r}{B})(c)$, since
  % the $\leq$-rule is not applicable, there exist
  % 
  % \begin{itemize}
  % \item Since \A clash-free, there exists model \Hmc
  % \item \A admissible -> interpretations $\I_{1}$, \dots, $\I_{k}$ 
  % \item in \A are only literal assertions, equality ($s\approx t$) or at-least assertions
  % \item since \A is complete, for at-least assertions there exists necessary successors (with
  %   respective types)
  % \item in admissibility for \ZH we have to look at all $A_{\oalpha}$
  % \end{itemize}
  % 
  % \todo[inline]{ausformulierung und andere richtung fehlt noch}
\end{proof}


Note that this lemma yields that for an inadmissible ABox \Ap, there exists no model of \CA and \Ap
with admissible types. Thus, due to Lemma~\ref{lem:model-has-abox}, we know that if all ABoxes which
label leaf nodes in a derivation are not admissible, then \CA is inconsistent.
%
However, the converse does not hold. If \Ap is admissible and clash-free, it is still possible that
there exists no model \Hmc of \CA and \Ap such that \ZH is admissible as the following example
shows.

\begin{example}\label{ex:repletion-necessary}
  Let $\Bmfex = (\Bmcex,\emptyset,\emptyset)$ with
  \begin{align*}
    \Bmcex  & = \lnot C(s) \quad\land\quad \oax{\lnot A(a)} \sqsubseteq
              C \quad\land\quad \lnot C \sqsubseteq \oax{A\sqsubseteq\bot}\\
    \intertext{be an \ALCALC-ontology. Then,}
    \Bmfbex & = \big(\lnot C(s) \quad\land\quad 
              A_{\oax{\lnot A(a)}} \sqsubseteq C \quad\land\quad
              \lnot C \sqsubseteq A_{\oax{A\sqsubseteq\bot}} ,\quad \emptyset\big)\\
    \intertext{is the outer abstraction of \Bmfex. The normalisation and clausification of \Bmfbex yields \CAex with}
    \Cex & = \{A_{\oax{\lnot A(a)}}(x) \to C(x), \quad \top\to C(x) \lor
           A_{\oax{A\sqsubseteq\bot}}(x)\},\\
    \Aex & = \{\lnot C(s)\}.\\
    \intertext{Any derivation of \CAex produces a leaf node labelled with}
    \Ap & = \{\lnot C(s),\ A_{\oax{A\sqsubseteq\bot}}(s)\}.
  \end{align*}
  %
  Clearly, \Ap is admissible and in any model \HH of \Ap such that \ZH is admissible there exists
  $d\in\Delta^{\Hmc}$ with $s^{\Hmc} = d$ and $d \in {A_{\oax{A\sqsubseteq\bot}}}^{\Hmc}$. Since \ZH
  is admissible, we know that
  $\Omc_{X}\coloneqq\bigwedge_{\bsf(\oalpha)\in
    X}\alpha\land\bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X} \alpha^{*}$ must be consistent
  for any $X\in\ZH$. Hence, in particular $X = \{A_{\oax{A\sqsubseteq\bot}}\} \notin \ZH$ since
  $\Omc_{X} = A \sqsubseteq \bot \ \land\ \lnot(\lnot A(a))$ is inconsistent. Therefore,
  $A_{\oax{\lnot A(a)}}$ must also be in the restricted type of $d$, i.e.\
  $d \in {A_{\oax{\lnot A(a)}}}^{\Hmc}$. We implicitly obtain an ABox
  \begin{align*}
    \App & = \{\lnot C(s),\ A_{\oax{A\sqsubseteq\bot}}(s),\ A_{\oax{\lnot A(a)}}(s)\}.
  \end{align*}
  Because of $A_{\oax{\lnot A(a)}}(x) \to C(x) \in \Cex$ and
  $\lnot C(s)\in\Aex$, we know that \Hmc cannot be model of \CAex. In fact, there exists no model
  $\Hmc'$ of \CAex such that $\Zmc_{\Hmc'}$ is admissible since \Bmfex is inconsistent.
  %
  % \vspace{2cm}
  % we know that $X = \{A_{\oax{A\sqsubseteq\bot}}\} \notin \ZH$ since
  % $\Omc_{X} = A \sqsubseteq \bot \ \land\ \lnot(\lnot A(a))$ is not consistent . Thus, we also have
  % $d \in {A_{\oax{\lnot A(a)}}}^{\Hmc}$. Because of $A_{\oax{\lnot A(a)}}(x) \to C(x) \in \Cex$ and
  % $\lnot C(s)\in\Aex$, we know that \Hmc cannot be model of \CAex. In fact, there exists no model
  % $\Hmc'$ of \CAex such that $\Zmc_{\Hmc'}$ is admissible since \Bmfex is inconsistent.
\end{example}

The above example illustrates that there can exist \enquote{implicitly negated} concept assertions
in a complete, clash-free meta ABox \Ap like $A_{\oax{\lnot A(a)}}(s)$ in the above example, i.e.\
concept assertions that would cause a clash if added to the ABox. In the proof of
Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, we had to add certain concept assertions in order to
ensure admissibility. To avoid adding concept assertions which cause such a clash, we add special
DL-clauses to \Cmc. Since for every context $c\in\Cbb$ an object axiom~$\alpha$ is either modelled
by $\I_{c}$ or not, we can assume w.l.o.g.\ that either $c\in\bsf(\oalpha)^{\Jb}$ or
$c\in\bsf(\oax{\alpha^{*}})^{\Jb}$. Thus, we can add the DL-clause
$\top\to\bsf(\oalpha)(x) \lor \bsf(\oax{\alpha^{*}})(x)$ without adding any logical consequences.

\begin{definition}[Repletion of DL-clauses]
  Let \Cmc be a set of \LM-clauses over \Msig and \A an \LM-ABox over \Msig. The \emph{repletion of
    \Cmc} is obtained from \Cmc by adding the \LM-clause
  \begin{align*}
    \top\to\ A_{\oalpha}(x)\ \lor\ A_{\oax{\alpha^{*}}}(x)
  \end{align*}
 to \Cmc for each
  $A_{\oalpha} \in \ran(\bsf)$ that occurs in \Cmc or \A, where
  $A_{\oax{\alpha^{*}}} = \bsf(\alpha^{*})$ and $\alpha^{*}$ is the weak negation of $\alpha$.

  For an \LM-ontology \Omcb, the \emph{repleted clausification} is obtained from the clausification \CA
  of \Omcb by replacing with its repletion.
\end{definition}

In the proof of Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, we needed $\Hmc^{*}$, which models
$A_{\oalpha}(c)$ where $A_{\oalpha}(c)\notin\A'$ and $\I_{i}\models\Bmc_{c_{i}}\land\alpha$.
%
If \Cmc is repleted and $A_{\oalpha}(c)\notin\Ap$, then we have 
$A_{\oax{\alpha^{*}}}(c)\in\Ap$. Hence, we know that $\I_{i}\models\alpha^{*}$ and, due to
Lemma~\ref{lem:weakly-negation-inconsistent}, $\I_{i}\not\models\alpha$. Thus,$\Hmc^{*}$ is not
needed anymore.

To sum up, we refine Algorithm~\ref{alg:1}, so it can be used with the hypertableau calculus. The
algorithm is depicted in Algorithm~\ref{alg:2}, where $\Omc_{c_{i}}$ is defined as in
Definition~\ref{def:admissibility-of-abox}. Instead of enumerating all models of
$\smash{\Omf^{\bsf}}$ up to essential equality, we traverse the clash-free, complete ABoxes in a
derivation of \CA and check whether there is an admissible ABox among them. To check admissibility,
we reuse the results of Section~\ref{sec:blackbox-approach}. Thus, $\Omc_{\Ap}$ and $\RO'$ are
defined analogous to Definition~\ref{def:renaming}. The next two lemmata show that
Algorithm~\ref{alg:2} is sound and complete.

\IncMargin{1em}
\RestyleAlgo{ruled}
\begin{algorithm}[t]
  \SetAlgoVlined
  \setstretch{1.1}
  \DontPrintSemicolon
  \SetKwData{true}{true}
  \SetKwData{false}{false}
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  %
  \Input{\LMLO-ontology \Omf}
  \Output{\true if \Omf is consistent, \false otherwise}
  \BlankLine
  %
  Preprocessing (results in \CA):\;
  1. Elimination of transitivity axioms, normalisation, clausification\;
  2. Repletion of DL-clauses\;
  %
  \BlankLine
  Let $(T,\lambda)$ be any derivation for \CA\;
  $\Amf \coloneqq \{ \Ap \mid \text{there exists a leaf node in $(T,\lambda)$ that is labelled with \Ap}\}$\;
  \For{$\Ap \in \Amf$}{
    \If{\Ap is clash-free}{
      \eIf{\Omf contains rigid names}{
        \If{($\Omc_{\Ap}, \RO')$ is consistent}{
          \vspace{0.5ex}\Return{\true}
        }
      }{
        Let $\{c_{1},\dots,c_{k}\}$ be the individuals occurring in \Ap\;
        \If{$(\Omc_{c_{i}}, \RO)$ is consistent for all $1 \leq i \leq k$}{
          \vspace{0.5ex}\Return{\true}
        }
      }
    }
  }
  \Return{false}
  \caption{Algorithm for checking consistency of \LMLO-ontology \Omf with Hypertableau}\label{alg:2}
\end{algorithm}

\begin{lemma}[Soundness]
  Let \Omf be an \LMLO-ontology. If Algorithm~\ref{alg:2} returns \false, then \Omf is inconsistent.
\end{lemma}
\begin{proof}
  If Algorithm~\ref{alg:2} returns \false, then in any derivation, all complete ABoxes either
  contain a clash or are not admissible. Assume that \Omf is consistent. Then, by
  Lemma~\ref{lem:consistant-and-admissible-types}, we know that there is some \Msig-interpretation \Hmc
  that models \CA, where $\Zmc_{\Hmc}$ is admissible. Due to
  Lemmata~\ref{lem:model-has-abox} and~\ref{lem:A-admissible-iff-ZH-admissible}, there then is
  some complete, clash-free ABox \Ap which is admissible. This contradicts the assumption and hence, \Omf
  must be inconsistent.
\end{proof}

\begin{lemma}[Completeness]
  Let \Omf be an \LMLO-ontology. If Algorithm~\ref{alg:2} returns \true, then \Omf is consistent.
\end{lemma}

\begin{proof}
  If Algorithm~\ref{alg:2} returns \true, then there exists some clash-free, complete ABox \Ap in
  any derivation of \CA such that \Ap is admissible. Due to
  Lemma~\ref{lem:A-admissible-iff-ZH-admissible}, there exists an \Msig-interpretation \Hmc such
  that $\Hmc\models\Ap$ and $\Zmc_{\Hmc}$ is admissible.  If $\bsf(\oax{\alpha})(c)\notin\Ap$, then
  due to the repletion we know that $\bsf(\oax{\alpha^{*}})(c)\in\Ap$. Since $\alpha\land\alpha^{*}$
  is inconsistent, we have that $\bsf(\oalpha)\notin\type_{\ran(\bsf)}^{\Hmc}(c^{\Hmc})$.
  Therefore, in the construction of $\Hmc$ no additional assertions must be assumed and \Hmc also
  models \CA.
  %
  Hence, by Lemma~\ref{lem:consistant-and-admissible-types}, \Omf is consistent.
\end{proof}

However, for the repletion, a lot of disjunctive DL-clauses are added to \Cmc which increases the
non-determinism tremendously. On closer inspection, we note that changing \Hmc to $\Hmc^{*}$ in the
proof of Lemma~\ref{lem:A-admissible-iff-ZH-admissible} is not dangerous in general. If $\Hmc^{*}$
additionally models $A(c)$ with $A\in\ran(\bsf)$ to ensure admissibility of $\Zmc_{\Hmc}$, where
$A(c)\notin\Ap$, then it only becomes problematic for a DL-clause containing $A$ in the
antecedent. This is shown in Example~\ref{ex:repletion-necessary}.
%
Conversely, we only have to introduce the repletion clauses for $A$ if $A$ appears in the antecedent
of some DL-clause. Note here, that in the mapping of Chapter~\ref{cha:mapping} only
Axiom~\eqref{eq:nested-cts} contains, after clausification, an abstracted meta concept in the
antecedent. Thus, if no compartment type plays any roles, then we do not need to add the repletion
clauses to the ontology of the role-based model.


\section{Implementing JConHT and Evaluation}
\label{sec:implementing-jconht}

We implemented Algorithm~\ref{alg:2} in a reasoner called \emph{JConHT} -- a \emph{J}ava-implemented
\emph{Con}text description logic reasoner based on \emph{H}ermi\emph{T}. Like HermiT, it is an OWL
compliant reasoner implementing the \textsf{OWLReasoner} interface of the OWL API.

Nearly all reasoners use the Web Ontology Language (OWL) in order to represent an ontology.
However, in general OWL cannot express contextualised knowledge. In~\cite{BoGH-ISWC03}, Bouquet et
al. introduce C-OWL, an extension of the OWL syntax and semantics to allow for the representation of
contextual ontologies. But their view differs significantly from our approach in what a context is.
Therefore, we cannot use C-OWL.

But OWL has other means to enrich an ontology with more information due to \emph{OWL
  annotations}. Annotations associate information with an ontology, for example name of the creator
of the ontology. But also concept, role and individual names, as well as axioms, can be annotated. We use the
outer abstraction of an ontology which is a `normal' DL-ontology and define the connection between
an abstracted concept name and the corresponding o-axiom via a special OWL annotation. We decided to
use the predefined OWL annotation property \rdfsIsDefinedBy for that purpose. We simply
annotate the o-axiom $\alpha$ with the abstracted meta concept name $A_{\oalpha}$.
%
Let us again consider Example~\ref{ex:outer-abstraction}:
\begin{example}\label{ex:outer-abstraction-as-OWL}
  Let \Omc be the \ALCALC-ontology
  \begin{align*}
    \Omc \coloneqq (C\sqsubseteq(\oax{A\sqsubseteq\bot})\ \land\ (C\sqcap\oax{A(a)})(c),\ \emptyset,\ \emptyset).
  \end{align*}
Then \Omc is presented in OWL 2 functional syntax as follows:

\smallskip\noindent
\verb+SubclassOf(cls:C cls:A_ASubBot)+\\
\verb+ClassAssertion(ObjectIntersectionOf(cls:C cls:A_Aa) ind:c)+\\
\verb+SubclassOf(Annotation(rdfs:isDefinedBy cls:A_ASubBot) cls:A owl:Bottom)+\\
\verb+ClassAssertion(Annotation(rdfs:isDefinedBy cls:A_Aa) cls:A ind:a)+
\end{example}

Furthermore, in practical applications we often encounter object axioms that must hold independently
of any context. These so-called \emph{global object axioms} are of the form
$\top \sqsubseteq \oalpha$. Using the above approach would introduce a new abstracted meta concept
for each such axiom and, thus, unnecessarily bloat the OWL ontology. To avoid this, we decided to use
another OWL annotation with a special meaning: \rdfsLabelGlobal.
%
Finally, we need to specify which concept and role names are rigid. Since only the ontology as a whole
and single axioms can be annotated, we use annotated declaration axioms. Declaration axioms do not
affect the consequences of an OWL 2 ontology, they simply declare the existence of an entity and
associate it with an entity type. We again use a special OWL annotation: \rdfsLabelRigid.
%
Consider a light variation of example~\ref{ex:outer-abstraction-as-OWL}:

\begin{example}\label{ex:outer-abstraction-as-OWL-w-global}
  Let \Omc be the \ALCALC-ontology
  \begin{align*}
    \Omc \coloneqq (\top\sqsubseteq(\oax{A\sqsubseteq\bot})\ \land\ \oax{A(a)}(c),\ \emptyset,\ \emptyset).
  \end{align*}
  with $A\in\OCR$. Then \Omc is represented in OWL 2 functional syntax as follows:

\smallskip\noindent
\verb+Declaration(Annotation(rdfs:label "rigid") Class (cls:A))+\\
\verb+ClassAssertion(cls:A_Aa ind:c)+\\
\verb+ClassAssertion(Annotation(rdfs:isDefinedBy cls:A_Aa) cls:A ind:a)+\\
\verb+SubclassOf(Annotation(rdfs:label "objectGlobal") cls:A owl:Bottom)+
\end{example}

In Chapter~\ref{cha:mapping}, we presented a mapping algorithm that translates constrained
$\Sigma$-compartment role object models into \LMLO-ontologies. We implemented this algorithm as part
of the reference implementation of CROM\footnote{\url{https://github.com/Eden-06/CROM}}. The result
of the mapping is an OWL ontology in Manchester OWL syntax~\cite{HoP-OWL2Man12} that uses the
special annotations introduced above to encode \LMLO.

To evaluate the implementation of our reasoner, we performed several benchmarks to test the
performance on ontologies that are based on CROM. Therefore, we used a CROM generator, which we explain
below in detail, that randomly generates models based on a pseudorandom number generator. These models are
then converted to OWL ontologies by the above mentioned mapping. We analyse the performance based on
three scenarios:
\begin{enumerate}[leftmargin=30pt]
\item[(I)] variation of the number of relationship types defined in a compartment type,
\item[(II)] variation of the number of role groups defined in a compartment type, and
\item[(III)] variation of the types that are allowed to fill role types, i.e.\ whether compartments
  are allowed to play roles.
\end{enumerate}


\begin{figure}
  \centering
  \subfloat[Scenario (I): Variation of number of relationship types.]{
    \begin{tikzpicture}
      \begin{axis}[ymode = log, ymin = 1, ymax = 25000,
                   clip=false,
                   width=0.5\textwidth,
                   xtick = {5,10,15,20,25,30,35,40},
                   legend style = {font=\footnotesize, legend pos = outer north east}]
        \addplot[mark=square*]   table [x=n, y=RST0-42, col sep=comma] {./data/ScenarioI.csv};
        \addplot[mark=triangle*] table [x=n, y=RSThalf-42, col sep=comma] {./data/ScenarioI.csv};
        \addplot[mark=*] table [x=n, y=RST1-42, col sep=comma] {./data/ScenarioI.csv};
        \addplot[only marks, mark=square]   table [x=n, y=RST0-127, col sep=comma] {./data/ScenarioI.csv};
        \addplot[only marks, mark=triangle] table [x=n, y=RSThalf-127, col sep=comma] {./data/ScenarioI.csv};
        \addplot[only marks, mark=o]   table [x=n, y=RST1-127, col sep=comma] {./data/ScenarioI.csv};
        \legend{$\rst0$,$\rst0.5$,$\rst1$,$\rst0^{*}$,$\rst0.5^{*}$,$\rst1^{*}$}
        % 
        \node[anchor = north east, font=\scriptsize, yshift=1mm] at (yticklabel* cs:1) {$t$ in $s$};
        \node[anchor = north east, font=\scriptsize, yshift=-6mm] at (xticklabel* cs:1) {$n$};
        %
        %\node[node] at(5,\Mean) {};
      \end{axis}
    \end{tikzpicture}%
  \label{fig:results-A}}%
  \hfil%
  \subfloat[Scenario (II): Variation of number of role groups.]{
    \begin{tikzpicture}
      \begin{axis}[ymode = log, ymin = 1, ymax = 25000,
                   clip = false, 
                   width=0.5\textwidth,
                   xtick = {5,10,15,20,25,30,35,40},
                   legend style = {font=\footnotesize, legend pos = outer north east}]
        \addplot[mark=square*]   table [x=n, y=RG0-42, col sep=comma] {./data/ScenarioII.csv};
        \addplot[mark=triangle*] table [x=n, y=Rghalf-42, col sep=comma] {./data/ScenarioII.csv};
        \addplot[mark=*]   table [x=n, y=RG1-42, col sep=comma] {./data/ScenarioII.csv};
        \addplot[only marks, mark=square]   table [x=n, y=RG0-127, col sep=comma] {./data/ScenarioII.csv};
        \addplot[only marks, mark=triangle] table [x=n, y=Rghalf-127, col sep=comma] {./data/ScenarioII.csv};
        \addplot[only marks, mark=o] table [x=n, y=RG1-127, col sep=comma] {./data/ScenarioII.csv};
        \legend{$\rg0$,$\rg0.5$,$\rg1$,$\rg0^{*}$,$\rg0.5^{*}$,$\rg1^{*}$}
        % 
        \node[anchor = north east, font=\scriptsize, yshift=1mm] at (yticklabel* cs:1) {$t$ in $s$};
        \node[anchor = north east, font=\scriptsize, yshift=-6mm] at (xticklabel* cs:1) {$n$};
      \end{axis}
    \end{tikzpicture}
  \label{fig:results-B}}%
  \hfil%
  \subfloat[Scenario (III): Variation of whether compartments can play roles.]{
    \begin{tikzpicture}
      \begin{axis}[ymode = log, ymin = 1, ymax = 25000,
                   clip = false,
                   width=0.5\textwidth,
                   xtick = {5,10,15,20,25,30,35,40},
                   legend style = {font=\footnotesize, legend pos = outer north east}]
        \addplot[mark=square*] table [x=n, y=CT0-42, col sep=comma] {./data/ScenarioIII.csv};
        \addplot[mark=*] table [x=n, y=CT1-42, col sep=comma] {./data/ScenarioIII.csv};
        \addplot[only marks, mark=square] table [x=n, y=CT0-127, col sep=comma] {./data/ScenarioIII.csv};
        \addplot[only marks, mark=o] table [x=n, y=CT1-127, col sep=comma] {./data/ScenarioIII.csv};
        \legend{$\ct{=}\bot$,$\ct{=}\top$,$\ct{=}\bot^{*}$,$\ct{=}\top^{*}$}
        %\addplot[mark=|] table [x=n, y=RST1, col sep=comma] {./data/Series_A_RST.csv};
        % 
        \node[anchor = north east, font=\scriptsize, yshift=1mm] at (yticklabel* cs:1) {$t$ in $s$};
        \node[anchor = north east, font=\scriptsize, xshift=0mm] at (xticklabel* cs:1) {$n$};
      \end{axis}
    \end{tikzpicture}
  \label{fig:results-C}}
  %
  \caption{Average execution times of JConHT for benchmark ontologies.}
  \label{fig:results-benchmark}
\end{figure}

The main idea of the CROM generator is to randomly produce role-based models which abstracted and
upscaled the banking example introduced in Chapter~\ref{cha:mapping}.  In detail, the CROM generator
works as follows.  It has three input parameters.  These are an integer $n$, which defines the size
of the model, an integer~$s$, which serves as the seed for the pseudorandom number generator,  and a
Boolean~$c$ which determines whether compartment types can fill role types.  Any random choice is
realised by a pseudorandom number generator based on seed~$s$. Hence, we can reproduce every
generated model.  For a given~$n$, the generator creates~$n$ compartment types, $n$ natural types,
and $n^{2}$ role types, i.e.\ $n$ role types for each compartment type. Depending on the test series, it also
generates $0$, $\nicefrac{n}{2}$ or $n$ relationship types per compartment type.
%
To generate \fills, we randomly select two filler types for each role type. If $c$ is \true, these
filler types can be any natural type or compartment type. If $c$ is \false, i.e.\ compartment types
are not allowed to play roles, then the filler types can only be natural types.
The \parts-relation is determined by construction, since any role type is already assigned to one
compartment type.
For \rel, we randomly pick two role types of the associated compartment type. Thus, we completely
defined a \SCROM~\Mmc.  Next, we define the constraint set.



We restricted the pairs of lower and upper bounds to $\{0..0, 0..1, 0..\infty, 1..1,
1..\infty\}$. To construct a role group within a compartment type, we randomly choose two role types
of that compartment type and a pair of lower and upper bounds. For the occurrence constraints we
assign one pair of lower and upper bound to each role type and each constructed role
group. Similarly, for the cardinality constraints we assign two pairs of lower and upper bounds to
each relationship type. In Section~\ref{sec:mapping-constraints}, we showed that our mapping can
only support limited intra-relationship constraints which in turn also restrict the cardinality
constraints for that relationship type. Therefore, we omit intra-relationship type constraints in
our benchmark.


The basic setting for the different scenarios is that we do not have any relationship types or role
groups, and that compartments are not allowed to fill roles. In Series~(A) we define $0$,
$\nicefrac{n}{2}$ or $n$ relationship types per compartment type.  
%
Analogously, in Series~(B) we construct $0$, $\nicefrac{n}{2}$ or $n$ role groups per compartment
type.
%
For Scenario~(III), we define $\nicefrac{n}{2}$ relationship types and construct $\nicefrac{n}{2}$
role groups. We then distinguish whether or not compartments can play roles.
% 
For each series, we start with $n=5$ and increase $n$ by steps of $5$ until the reasoner throws
out-of-memory exceptions. At each single configuration, we create 100 models with seeds from $1$ to
$100$. We measure the time that the reasoner needs to decide consistency and calculate the average.


Our tests were conducted on a 64-bit Ubuntu 14-04 machine equipped with an Intel Core i5-2500
quad-core processor with a CPU clock rate of 3.3 GHz and 16 GB main memory. For the execution of the
reasoner we used \textsf{Java8} by \textsf{OpenJDK} and restricted the maximum Java heap size to
12GB.
%
To measure the time needed by the reasoner to decide consistency, we used the shell builtin command
\texttt{time} of Unix operation systems and measured the accumulated execution time.

Figure~\ref{fig:results-benchmark} shows the results of our tests. All diagrams show the average
computation time that the reasoner needed to decide consistency. In some cases, the reasoner threw an
out-of-memory exception and did not finish. We excluded these data from the average and plotted them
separately.
%
For all data sets, their starred version denotes the average time in the case the reasoner exited
with an out-of-memory exception. If no such data point exists for a smaller $n$, then all ontologies
could be processed without problems.
%
Note here, that the time axis is logarithmic and that the reasoning time exponentially increases in
the size of $n$, and thus in the size of the input ontology.

In Figure~\ref{fig:results-A}, $\rst0$ denotes the data set where no relationship types appear. In
$\rst0.5$, every model has $\nicefrac{n}{2}$ relationship types and in $\rst1$ there are $n$
relationship types. Intuitively, the more relationship types and, hence, cardinality constraints a
model contains, the harder it is to reason about. If only few constraints appear in the model, it is
probable that the first branch of the derivation tree in the hypertableau algorithm already yields a
consistent interpretation and no backtracking is needed. With more constraints, backtracking is
needed more often, which increases the computation time significantly. An unsatisfiable role-based
model is the most expensive to reason upon, since here complete backtracking is necessary before the
algorithm can determine that the model is unsatisfiable.
%
Interestingly, there is not much difference between $\rst0.5$ and $\rst1$. So, once relationship
types are introduced, it is not relevant how many of them are defined. Furthermore, once
out-of-memory exceptions appear, the reasoning time of the more difficult models is distorted since
they would have needed more time if more resources would have been available. This explains the
decline of $\rst0.5$ for higher $n$.


The results for Scenario~(II), shown in Figure~\ref{fig:results-B}, are similar to
Scenario~(I). Analogously, $\rg0$, $\rg0.5$ and $\rg1$ respectively denote the data sets where no,
$\nicefrac{n}{2}$ and $n$ role groups appear in the role-based model. Again, when more constraints
are introduced, it gets harder to decide satisfiability. However, it can be realised that
introducing role groups is computation-wise costlier than relationship types with cardinality
constraints.

In Figure~\ref{fig:results-C}, $\ct{=}\bot$ denotes the average reasoning time if no compartments
are allowed to play roles. In $\ct{=}\top$, compartments were allowed to play roles.
%
If compartments are allowed to play roles, due to Axiom~\eqref{eq:nested-cts}, we have to add the
repletion clauses. These introduce a large amount of non-determinism. This explains why the
reasoning time increases and out-of-memory exceptions appear even for smaller~$n$.

In the end it is hard to tell whether these randomly generated role-based models give realistic test
results. The tests clearly show that more constraints directly influence the computation
time. Anyway, the application scope for role-based modelling is quite broad and these test give an
impression for a general setting. However, a further examination of models within a specific topic
can result in more target-oriented tests which might even initiate further specialised optimisations
in the algorithm.

% We next present how we implement our algorithm. The main components that we discuss are the
% \texttt{ContextOntology}, \texttt{ContextReasoner} and \texttt{ContextTableau} classes. 

% The \texttt{ContextOntology} class stores the specially formatted input OWL ontology as
% \textsf{rootOntology}. The constructor additionally extracts the outer abstraction, i.e.\ all
% logical OWL axioms in \textsf{rootOntology} that are not annotated with \rdfsIsDefinedBy or
% \rdfsLabelGlobal, and stores the connection of the abstracted concept names and corresponding the
% o-axioms in a hash map.  If necessary, the repletion of the DL-clauses is handled here, too. Since
% we cannot directly add DL-clauses at this stage, we add the axiom
% $\top\sqsubseteq \bsf(\oalpha)\sqcup\bsf(\oax{\alpha^{*}})$, which is then transformed into the
% according DL-clause.
% %
% The class also provides a method \mbox{\textsf{getMetaOntology()}} to return the outer abstraction.
% A separate method allows to retrieve all global object axioms as a stream of \textsf{OWLAxiom}s.
% %
% If no rigid names are present, the method \textsf{getObjectOntology($X_{1}$)} returns an OWL
% ontology which is an conjunction of all global object axioms, all object axioms corresponding to the
% positively asserted abstracted meta concepts in $X_{1}$ and the weakly negation of all object axioms
% corresponding to the negatively asserted abstracted meta concepts in $X_{1}$. Here, $X_{1}$ is an
% instance of the class \texttt{RestrictedType}, essentially a pair $(\Xpos,\Xneg)$ of sets of
% positively and negatively asserted, abstracted concept names.
% %
% If rigid names are present, \textsf{getObjectOntology($X_{1},\dots,X_{k}$)} returns the overall OWL
% ontology after applying the renaming technique to the the single axioms according to
% Definition~\ref{def:renaming}.  The output of \texttt{getObjectOntology($\cdot$)} is used to check
% admissibility.


% The class \texttt{ContextReasoner} is a subclass of HermiT's \texttt{Reasoner} class and thereby
% implements the \texttt{OWLReasoner} interface of the OWL API. Compared to HermiT's \texttt{Reasoner}
% it only changes the tableau to be a \texttt{ContextTableau}.

% The main parts of our algorithm are implemented in the \texttt{ContextTableau} class which is a
% subclass of HermiT's \texttt{Tableau} class.  In HermiT, the \texttt{runCalculus()} method of
% \texttt{Tableau} runs the hypertableau algorithm trying to build a model of \CA.  Its
% \texttt{ExtensionManager} contains the set of assertions of an ABox that labels a node in a
% derivation. When no derivation rule is applicable and if the \texttt{ExtensionManager} is
% clash-free, it contains a pre-model, i.e. the set of assertions from which through unraveling a
% model of \CA can be constructed, proving the consistency of \CA.  If the \texttt{ExtensionManager}
% contains a clash, backtracking is triggered and the next leaf in the derivation is considered.

% We override \texttt{runCalculus()} in \texttt{ContextTableau} such that it also returns true if and
% only if the input context ontology is consistent.  Therefore we implement an method
% \texttt{consistentInterpretations()} that returns a stream of models of the meta ontology, i.e.\ the
% outer abstraction of the input ontology.  It internally uses \texttt{Tableau}'s \texttt{runCalculus()}
% to calculate the models. It reads off the pre-model of the \texttt{ExtensionManager} and sets a
% clash afterwards, so that for the next stream element \texttt{Tableau}'s \texttt{runCalculus()}
% calculates the next pre-model.

% This stream of pre-models is filtered for admissible 


% As every relevant description logic reasoner uses the Web Ontology Language (OWL), we have to adapt
% our general setting in order to stay compliant with the usual assumptions. Most importantly OWL does
% not make the unique name assumption. In contrast to the arguments given in section
% \ref{sec:description-logics} in favour of the UNA, individual names are rather seen as an label for
% an object in OWL. Especially if one wants to merge two different ontologies talking about the same
% topic, it seems quite natural to be able to state that two individual names actually represent the
% same object. Furthermore, OWL2 allows for a so-called \emph{Individual Inequality Axiom} which can be
% used to axiomatise the unique name assumption if needed.

% As a design decision we chose to also neglect the UNA in our case. Consequently, we then also drop
% the rigid individual assumption we made in chapter \ref{cha:context-dls}. When individual names are
% seen as labels, of course, these could change from context to context. To be also able to express
% rigid individuals we analogously introduce the set of \emph{rigid individual names }$\OIR \subseteq
% \OI$. Straightforward we adapt the notions of a nested interpretation and of admissibility.

% \begin{definition}[Nested interpretation (without RIA)]\label{def:nested-interpretation-without-ria}
% A \emph{nested interpretation} is a tuple \JJ, where \Cbb is a non-empty set (called
%   \emph{contexts}) and $(\Cbb,\cdot^\J)$ is an \Msig-interpretation.
%   %
%   Moreover, for every $c\in\Cbb$, $\I_c\coloneqq(\Delta^{\J},\cdot^{\I_c})$ is an \Osig-interpretation
%   such that we have for all $c,c'\in\Cbb$ that $x^{\I_{c}}=x^{\I_{c'}}$ for every
%   $x\in\OIR\cup\OCR\cup\ORR$.
% \end{definition}

% \begin{definition}[Admissibility (without RIA)]\label{def:admissibility-without-ria}
%   Let $\Xmc=\{X_1,~\dots,\ X_k\}\subseteq\powerset{\ran(\bsf)}$.  We call \Xmc \emph{admissible} if
%   there exist \Osig-interpretations $\I_1=(\Delta,\cdot^{\I_1})$,~\dots,
%   $\I_k=(\Delta,\cdot^{\I_k})$ such that
%   \begin{enumerate}
%   \item $x^{\I_i}=x^{\I_j}$ for all $x\in\OIR\cup\OCR\cup\ORR$ and all $i,j\in\{1,\dots,k\}$, and
%   \item every $\I_i$, $1\le i\le k$, is a model of the \LO-BKB $\Bmf_{X_{i}}= (\B_{X_i},\RO)$
%     over~\Osig where
%     \begin{align*}
%       \B_{X_i}:=\bigwedge_{\bsf(\oalpha)\in X_i}\alpha\ \land
%       \bigwedge_{\bsf(\oalpha)\in\ran(\bsf)\setminus X_i}\lnot\alpha.
%     \end{align*}
%   \end{enumerate}
%   \vspace{-1.7\baselineskip}
% \end{definition}




% \todo[inline]{What happens with complexity results?}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% reftex-default-bibliography: ("../references.bib")
%%% End:

%  LocalWords:  performant axiomatise iff logics clausification inline ABox ontologies workflow DL
%  LocalWords:  bijection subtasks nominals conformant hypertableau DLs Konclude API HermiT ABoxes
%  LocalWords:  blockable Preprocessing OWLReasoner et al ava preprocessing equisatisfiable
%  LocalWords:  transitiviy pseudorandom scalably upscaled
